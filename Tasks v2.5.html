<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø¯ÙŠØ± Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>

    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* General body styling */
        body { 
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #111827; /* Default dark bg for the whole app */
            color: #f9fafb; /* Default light text for dark bg */
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            overscroll-behavior-y: contain; /* from doonp.html */
        }
        *, *:before, *:after { box-sizing: inherit; }

        /* --- Styles from doonp.html (TASKS WIDGET) --- */
        #widget-container .task-drag-over { border-top: 2px dashed #60a5fa; margin-top: -2px; z-index: 1; }
        #widget-container .task-dragging { opacity: 0.5; cursor: grabbing; background-color: #374151; }
        #widget-container .task-item { touch-action: pan-y; user-select: none; transition: transform 0.3s ease-out, background-color 0.3s ease-out, opacity 0.3s ease-out, box-shadow 0.3s ease-in-out; will-change: transform, box-shadow; overflow: visible; }
        #widget-container .task-item.swiping { touch-action: none; transition: background-color 0.1s linear; }
        #widget-container .swipe-indicator { position: absolute; top: 0; bottom: 0; width: 100%; display: flex; align-items: center; padding: 0 0.5rem; color: white; border-radius: inherit; z-index: 5; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-out; }
        #widget-container .swipe-indicator.left { right: 0; justify-content: flex-start; border-top-right-radius: 0.25rem; border-bottom-right-radius: 0.25rem; border-top-left-radius: 0; border-bottom-left-radius: 0; }
        #widget-container .swipe-indicator.right { left: 0; justify-content: flex-end; border-top-left-radius: 0.25rem; border-bottom-left-radius: 0.25rem; border-top-right-radius: 0; border-bottom-right-radius: 0; }
        #widget-container .task-item.swipe-ready-delete { background-color: rgba(239, 68, 68, 0.5); }
        #widget-container .task-item.swipe-ready-star { background-color: rgba(245, 158, 11, 0.5); }
        #widget-container .task-item.swipe-delete-active { transform: translateX(-150%) !important; opacity: 0; transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
        #widget-container .task-list::-webkit-scrollbar { display: none; }
        #widget-container .task-list { -ms-overflow-style: none; scrollbar-width: none; }
        #widget-container input[type="checkbox"] { accent-color: #3b82f6; }
        #widget-container input[type="search"]::-webkit-search-cancel-button { -webkit-appearance: none; height: 1em; width: 1em; margin-left: .4em; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%239ca3af'><path d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/></svg>"); background-size: 1em 1em; cursor: pointer; filter: invert(0.2); }
        
        #action-snackbar { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%) translateY(150%); color: white; padding: 0.75rem 1rem; border-radius: 0.375rem; display: flex; justify-content: space-between; align-items: center; min-width: 280px; max-width: 90%; z-index: 100; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06); transition: transform 0.3s ease-out, background-color 0.3s ease-in-out; text-align: right; }
        #action-snackbar.show { transform: translateX(-50%) translateY(0); }
        #action-snackbar.type-delete { background-color: #374151; }
        #action-snackbar.type-success { background-color: #059669; }
        #action-snackbar.type-info { background-color: #2563eb; }
        #action-snackbar-btn { background-color: #ef4444; color: white; border: none; width: 2.5rem; height: 2.5rem; border-radius: 9999px; margin-right: 1rem; cursor: pointer; font-weight: bold; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; }
        #action-snackbar-btn:hover { background-color: #dc2626; }
        #action-snackbar-message { flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        
        #widget-container .recurring-icon { display: inline-block; vertical-align: middle; margin-right: 0.25rem; }
        #widget-container .recurring-icon svg { width: 12px; height: 12px; }
        #widget-container { height: 100vh; overflow-y: hidden; }
        #widget-container #task-list-container { flex-grow: 1; overflow-y: auto; padding-right: 0.25rem; padding-bottom: 5rem; min-height: 100px; }
        #widget-container > div:first-child,
        #widget-container > div:last-child { flex-shrink: 0; }
        #widget-container .task-meta-line { display: flex; align-items: center; flex-wrap: wrap; gap: 0.4rem 0.8rem; font-size: 0.75rem; line-height: 1.25; }
        #widget-container .task-meta-line svg { margin-left: 0.25rem; flex-shrink: 0; width: 12px; height: 12px; }
        #widget-container .task-priority-info, #widget-container .task-time-info, #widget-container .task-countdown, #widget-container .task-duration-info, #widget-container .task-timer-display, #widget-container .task-category-info, #widget-container .linked-plan-info-display { color: #9ca3af; }
        #widget-container .task-priority-high { color: #ef4444; } #widget-container .task-priority-medium { color: #f59e0b; } #widget-container .task-priority-low { color: #22c55e; }
        #widget-container .task-priority-high svg { stroke: #ef4444; fill: #ef4444; } #widget-container .task-priority-medium svg { stroke: #f59e0b; fill: #f59e0b; } #widget-container .task-priority-low svg { stroke: #22c55e; fill: #22c55e; }
        #widget-container .task-time-info svg { stroke: #9ca3af; } #widget-container .task-duration-info svg { stroke: #9ca3af; } #widget-container .task-timer-display svg { stroke: #60a5fa; }
        #widget-container .task-timer-display.active { color: #60a5fa; font-weight: bold; } #widget-container .task-category-info svg { stroke: #9ca3af; fill: #9ca3af;}
        #widget-container .task-countdown.overdue { color: #ef4444; } #widget-container .task-countdown.soon { color: #f59e0b; }
        #widget-container .task-countdown.overdue svg { stroke: #ef4444; fill: none; } #widget-container .task-countdown.soon svg { stroke: #f59e0b; fill: none; }
        #widget-container .actionsDiv .action-btn, #widget-container .actionsDiv .play-pause-timer-btn, #widget-container .actionsDiv .reset-timer-btn, #widget-container .actionsDiv .remove-timer-btn, #widget-container .actionsDiv .toggle-description-action-btn { background-color:transparent; color:#9ca3af; width:1.75rem; height:1.75rem; display:inline-flex; align-items:center; justify-content:center; border-radius:9999px; font-size:0.8rem; cursor:pointer; transition:background-color .2s,color .2s, border-color .2s; border:1px solid transparent; }
        #widget-container .actionsDiv .action-btn:hover, #widget-container .actionsDiv .play-pause-timer-btn:hover, #widget-container .actionsDiv .reset-timer-btn:hover, #widget-container .actionsDiv .remove-timer-btn:hover, #widget-container .actionsDiv .toggle-description-action-btn:hover { background-color:#374151; color:#e5e7eb; }
        #widget-container .actionsDiv .action-btn svg, #widget-container .actionsDiv .play-pause-timer-btn svg, #widget-container .actionsDiv .reset-timer-btn svg, #widget-container .actionsDiv .remove-timer-btn svg, #widget-container .actionsDiv .toggle-description-action-btn svg, #widget-container .actionsDiv .action-btn i, #widget-container .actionsDiv .play-pause-timer-btn i, #widget-container .actionsDiv .reset-timer-btn i, #widget-container .actionsDiv .remove-timer-btn i, #widget-container .actionsDiv .toggle-description-action-btn i { width:0.9em; height:0.9em; margin-left:0; }
        #widget-container .actionsDiv .play-pause-timer-btn { border-color: #4b5563; } #widget-container .actionsDiv .reset-timer-btn { border-color: #4b5563; } #widget-container .actionsDiv .remove-timer-btn { border-color: #4b5563; }
        #widget-container .actionsDiv .play-pause-timer-btn.playing { border-color:#f59e0b; color:#f59e0b; } #widget-container .actionsDiv .play-pause-timer-btn.playing:hover { background-color:rgba(245,158,11,.1); }
        #widget-container .actionsDiv .play-pause-timer-btn.paused { border-color:#22c55e; color:#22c55e; } #widget-container .actionsDiv .play-pause-timer-btn.paused:hover { background-color:rgba(34,197,94,.1); }
        #widget-container .actionsDiv .reset-timer-btn { border-color:#6b7280; color:#6b7280; } #widget-container .actionsDiv .reset-timer-btn:hover { background-color:rgba(107,114,128,.1); }
        #widget-container .actionsDiv .remove-timer-btn { border-color:#ef4444; color:#ef4444; } #widget-container .actionsDiv .remove-timer-btn:hover { background-color:rgba(239,68,68,0.1); }
        #widget-container .task-timer-reset-remove-controls { display: inline-flex; align-items: center; gap: 0.25rem; }
        
        #widget-container .task-item .task-description-content { padding: 0.5rem; font-size: 0.8rem; color: #cbd5e0; line-height: 1.4; white-space: pre-wrap; border: 1px solid transparent; border-radius: 0.25rem; background-color: rgba(75, 85, 99, 0.1); margin-bottom: 0.75rem;}
        #widget-container .task-item .task-description-content textarea { width: 100%; min-height: 60px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 0.25rem; padding: 0.5rem; font-size: 0.8rem; line-height: 1.4; resize: vertical; box-sizing: border-box; }
        #widget-container .task-item .task-description-content textarea:focus { outline: none; border-color: #3b82f6; }
        #widget-container .task-item .edit-description-btn { font-size: 0.7rem; color: #9ca3af; cursor: pointer; padding: 0.1rem 0.25rem; border-radius: 0.25rem; background-color: transparent; margin-right: 0.5rem; vertical-align: middle; }
        #widget-container .task-item .edit-description-btn:hover { color: #e5e7eb; background-color: #374151; }
        #widget-container .description-edit-controls { margin-top: 0.5rem; display: flex; justify-content: flex-end; gap: 0.5rem; }
        #widget-container .description-edit-controls button { padding: 0.25rem 0.75rem; font-size: 0.75rem; border-radius: 0.25rem; color: white; }
        #widget-container .description-edit-controls .save-desc-btn { background-color: #2563eb; } #widget-container .description-edit-controls .save-desc-btn:hover { background-color: #1d4ed8; }
        #widget-container .description-edit-controls .cancel-desc-btn { background-color: #4b5563; } #widget-container .description-edit-controls .cancel-desc-btn:hover { background-color: #6b7280; }
        #widget-container .task-item .description-text-display { display: inline; }
        
        #widget-container #filter-dropdown-content { position: absolute; top: calc(100% + 0.5rem); left: 0; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06); z-index: 60; width: 280px; padding: 0.75rem; }
        #widget-container #filter-dropdown-content label { display: block; font-size: 0.875rem; color: #9ca3af; margin-bottom: 0.25rem; }
        #widget-container #filter-dropdown-content select, #widget-container #filter-dropdown-content .completion-filter-btn { width: 100%; margin-bottom: 0.5rem; }
        #widget-container #filter-dropdown-content .completion-filter-container { display: flex; gap: 0.25rem; }
        #widget-container #filter-dropdown-content .completion-filter-container button { flex-grow: 1; }
        #widget-container #category-filter-select { background-color: #4b5563; border: 1px solid #6b7280; color: white; padding: 0.5rem; border-radius: 0.25rem; font-size:0.875rem; }
        #widget-container .completion-filter-btn { background-color: #4b5563; color: #d1d5db; padding: 0.375rem 0.75rem; border-radius: 0.25rem; border: 1px solid #6b7280; font-size: 0.75rem; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
        #widget-container .completion-filter-btn:hover { background-color: #6b7280; }
        #widget-container .completion-filter-btn.active { background-color: #10b981; border-color: #059669; color: white; }
        
        #add-task-fab { position: fixed; bottom: 2rem; right: 2rem; width: 3.5rem; height: 3.5rem; background-color: #2563eb; color: white; border-radius: 9999px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3); cursor: pointer; z-index: 40; transition: transform 0.2s ease-out, opacity 0.3s; }
        #add-task-fab:hover { background-color: #1d4ed8; transform: scale(1.05); }
        #add-task-fab svg { width: 1.5rem; height: 1.5rem; }
        .hidden { display: none !important; }
        
        #widget-container #filter-icon-btn { background-color: transparent; border: none; width: 2rem; height: 2rem; }
        #widget-container #filter-dropdown-content { width: 260px; }
        #widget-container .filter-pill { display: inline-flex; align-items: center; background-color: #3b82f6; color: white; padding: 0.25rem 0.6rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 500; animation: fadeIn 0.3s ease-out; }
        #widget-container .filter-pill .remove-pill-btn { margin-right: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 50%; width: 1rem; height: 1rem; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; cursor: pointer; transition: background-color 0.2s; }
        #widget-container .filter-pill .remove-pill-btn:hover { background: rgba(0,0,0,0.4); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        #smart-view-switcher { display: inline-flex; background-color: #374151; border-radius: 9999px; border: 1px solid #4b5563; overflow: hidden; box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05); }
        #smart-view-switcher button { background-color: transparent; color: #d1d5db; border: none; cursor: pointer; transition: background-color 0.2s, color 0.2s; display: flex; align-items: center; height: 2.25rem; }
        #smart-view-switcher button:hover { background-color: #4b5563; }
        #smart-view-switcher-main { padding: 0 0.75rem 0 0.5rem; font-size: 0.8rem; font-weight: 500; }
        #smart-view-switcher-main:disabled { opacity: 0.5; cursor: not-allowed; background-color: transparent; }
        #smart-view-switcher-main i { margin-left: 0.5rem; font-size: 0.9em; color: #9ca3af; }
        #smart-view-switcher-dropdown-btn { padding: 0 0.5rem; border-right: 1px solid #4b5563; }
        #smart-view-switcher-dropdown-btn i { font-size: 0.7em; }

        #date-view-dropdown { position: absolute; top: calc(100% + 0.5rem); right: 0; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06); z-index: 60; width: 180px; padding: 0.5rem; }
        #date-view-dropdown button { display: flex; align-items: center; width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; color: #d1d5db; border-radius: 0.25rem; text-align: right; }
        #date-view-dropdown button:hover { background-color: #4b5563; color: white; }
        #date-view-dropdown button.active { background-color: #2563eb; color: white; }
        #date-view-dropdown button i { width: 1.25rem; margin-left: 0.5rem; }

        #date-nav-container .nav-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 0.25rem; border-radius: 0.375rem; transition: background-color 0.2s; min-width: 40px; }
        #date-nav-container .nav-item:hover { background-color: #374151; }
        #date-nav-container .nav-item .nav-item-label { font-size: 0.65rem; color: #9ca3af; margin-bottom: 0.125rem; }
        #date-nav-container .nav-item .nav-item-circle { width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s, color 0.2s, box-shadow 0.2s, transform 0.2s; }
        #date-nav-container .nav-item.selected .nav-item-circle { background-color: #2563eb; color: white; }
        #date-nav-container .nav-item.today .nav-item-circle { box-shadow: 0 0 0 2px #f59e0b; }
        #date-nav-container .nav-item.different-month { opacity: 0.5; }

        .subtask-indicator { display: inline-flex; align-items: center; background-color: #374151; color: #d1d5db; padding: 0.1rem 0.5rem; border-radius: 9999px; font-size: 0.7rem; font-weight: 500; margin-right: 0.5rem; }
        .subtask-indicator.all-done { background-color: #166534; color: #dcfce7; }
        .subtask-indicator svg { width: 10px; height: 10px; margin-left: 0.25rem; }
        
        .subtask-display-item { display: flex; align-items: center; padding: 0.3rem 0; font-size: 0.8rem; }
        .subtask-display-item input[type="checkbox"] { width: 0.9rem; height: 0.9rem; margin-left: 0.5rem; flex-shrink: 0; }
        .subtask-display-item label { cursor: pointer; transition: color 0.2s, text-decoration 0.2s; }
        .subtask-display-item input:checked + label { color: #6b7280; text-decoration: line-through; }

        .task-actions-dropdown { position: absolute; top: calc(100% + 4px); left: 0; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06); z-index: 10; width: 180px; overflow: hidden; animation: fadeIn 0.15s ease-out; }
        .task-actions-dropdown button { display: flex; align-items: center; width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; color: #d1d5db; text-align: right; }
        .task-actions-dropdown button:hover { background-color: #4b5563; color: white; }
        .task-actions-dropdown button i { width: 1.25rem; margin-left: 0.5rem; color: #9ca3af; }
        .task-actions-dropdown button.delete-action:hover { background-color: #991b1b; }
        .task-actions-dropdown button.delete-action:hover i { color: #fca5a5; }

        #date-nav-container { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; flex-wrap: nowrap; justify-content: flex-start; cursor: grab; position: relative; }
        #date-nav-container::-webkit-scrollbar { display: none; }
        #date-nav-container.dragging { cursor: grabbing; user-select: none; }
        #date-nav-container .nav-item { flex-grow: 0; flex-shrink: 0; min-width: 45px; }

        .week-nav-item { display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; padding: 0.25rem; flex-shrink: 0; margin: 0 0.125rem; -webkit-tap-highlight-color: transparent; }
        .week-nav-item .week-content-wrapper { display: flex; align-items: center; justify-content: center; border-radius: 9999px; font-weight: 500; transition: width 0.4s ease-in-out, background-color 0.3s ease, padding 0.4s ease-in-out; overflow: hidden; white-space: nowrap; width: 2.5rem; height: 2.5rem; padding: 0; background-color: #374151; color: #d1d5db; }
        .week-nav-item:hover .week-content-wrapper { background-color: #4b5563; }
        .week-nav-item.selected .week-content-wrapper { width: auto; padding: 0 0.75rem; background-color: #2563eb; color: white; }
        .week-nav-item .week-number { font-size: 0.9rem; font-weight: bold; transition: margin 0.4s ease-in-out; }
        .week-nav-item .week-range { font-size: 0.75rem; color: #e5e7eb; max-width: 0; opacity: 0; overflow: hidden; transition: max-width 0.3s ease-in-out 0.1s, opacity 0.2s ease-in 0.1s, margin-left 0.4s ease-in-out; }
        .week-nav-item .week-range .separator { margin: 0 0.4rem; opacity: 0.6; }
        .week-nav-item.selected .week-range { max-width: 150px; opacity: 1; margin-left: 0.25rem; }

        #date-nav-container.months-view { transition: justify-content 0.4s ease-in-out; }
        #date-nav-container.months-view .nav-item { transition: max-width 0.4s ease-in-out, opacity 0.3s ease-in-out 0.1s, padding 0.4s ease-in-out, margin 0.4s ease-in-out; overflow: hidden; white-space: nowrap; }
        #date-nav-container.months-view.months-view-collapsed .nav-item.out-of-quarter { max-width: 0; opacity: 0; padding-left: 0; padding-right: 0; margin-left: 0; margin-right: 0; pointer-events: none; }
        .month-view-toggle { flex-shrink: 0; margin-right: 0.5rem; background-color: #374151; border: 1px solid #4b5563; color: #d1d5db; width: 2.25rem; height: 2.25rem; border-radius: 9999px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s, transform 0.3s ease; }
        .month-view-toggle:hover { background-color: #4b5563; }
        .month-view-toggle i { transition: transform 0.3s ease-in-out; }
        #date-nav-container.months-view.months-view-collapsed .month-view-toggle i { transform: rotate(0deg); }
        #date-nav-container.months-view:not(.months-view-collapsed) .month-view-toggle i { transform: rotate(180deg); }

        .task-main-content { cursor: pointer; }
        .expand-indicator { transition: transform 0.3s ease-out; color: #6b7280; }
        .task-item.expanded .expand-indicator { transform: rotate(90deg); }
        .task-details-container { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.4s ease-out, opacity 0.3s ease-out, margin-top 0.4s ease-out; margin-top: 0; padding-left: calc(0.75rem + 5px + 1.25rem); border-top: 1px solid transparent; transition: border-color 0.4s ease-out; }
        .task-item.expanded .task-details-container { max-height: 500px; opacity: 1; margin-top: 0.75rem; padding-top: 0.75rem; border-top-color: #374151; }
        .subtasks-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; background-color: rgba(75, 85, 99, 0.2); }
        .subtasks-controls h5 { font-size: 0.8rem; font-weight: 600; color: #d1d5db; }
        .toggle-subtasks-btn { background-color: transparent; border: 1px solid #4b5563; color: #9ca3af; padding: 0.25rem 0.5rem; font-size: 0.7rem; border-radius: 9999px; cursor: pointer; transition: all 0.2s; }
        .toggle-subtasks-btn:hover { background-color: #4b5563; color: white; }
        .toggle-subtasks-btn .fa-chevron-down { transition: transform 0.3s ease-out; }
        .task-details-container.subtasks-visible .toggle-subtasks-btn .fa-chevron-down { transform: rotate(180deg); }
        .subtasks-list-container { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.2s ease-out, margin-top 0.3s ease-out; margin-top: 0; }
        .task-details-container.subtasks-visible .subtasks-list-container { max-height: 200px; opacity: 1; margin-top: 0.5rem; overflow-y: auto; }

        .task-stats-container { margin-top: 0.75rem; padding: 0.5rem 0.75rem; background-color: rgba(30, 41, 59, 0.5); border-radius: 0.375rem; border: 1px solid #374151; }
        .task-stats-container h5 { font-size: 0.8rem; font-weight: 600; color: #d1d5db; margin-bottom: 0.5rem; }
        .stat-item { display: flex; align-items: center; font-size: 0.75rem; color: #9ca3af; margin-bottom: 0.25rem; }
        .stat-item i { width: 1.25rem; margin-left: 0.5rem; color: #6b7280; }

        #reschedule-flyout { position: fixed; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.375rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -1px rgba(0,0,0,0.06); z-index: 15; width: 180px; overflow: hidden; animation: fadeIn 0.15s ease-out; }
        #reschedule-flyout button.flyout-btn { display: flex; align-items: center; width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; color: #d1d5db; text-align: right; border: none; background-color: transparent; cursor: pointer; }
        #reschedule-flyout button.flyout-btn:hover { background-color: #4b5563; color: white; }
        #reschedule-flyout button.flyout-btn i { width: 1.25rem; margin-left: 0.5rem; color: #9ca3af; }

        #date-nav-container.drop-target-active { box-shadow: 0 0 15px 2px rgba(59, 130, 246, 0.6); border-radius: 8px; transition: box-shadow 0.3s ease-in-out; }
        #date-nav-container.drop-target-active .nav-item,
        #date-nav-container.drop-target-active .week-nav-item { opacity: 0.8; }
        #date-nav-container .nav-item.drop-hover .nav-item-circle { background-color: #1d4ed8; transform: scale(1.15); color: white; box-shadow: 0 0 8px rgba(96, 165, 250, 0.8); }
        #date-nav-container .week-nav-item.drop-hover .week-content-wrapper { background-color: #1d4ed8; transform: scale(1.1); box-shadow: 0 0 8px rgba(96, 165, 250, 0.8); }

        .week-nav-item.spanning-week .week-content-wrapper { position: relative; }
        .week-nav-item.spanning-week.span-starts-prev .week-content-wrapper::before { content: ''; position: absolute; right: -2px; top: 20%; bottom: 20%; width: 3px; background-color: #6b7280; border-radius: 3px; opacity: 0.8; }
        .week-nav-item.spanning-week.span-ends-next .week-content-wrapper::after { content: ''; position: absolute; left: -2px; top: 20%; bottom: 20%; width: 3px; background-color: #6b7280; border-radius: 3px; opacity: 0.8; }
        .week-nav-item.selected.spanning-week.span-starts-prev .week-content-wrapper::before,
        .week-nav-item.selected.spanning-week.span-ends-next .week-content-wrapper::after { background-color: rgba(255, 255, 255, 0.6); }
        
        #contextual-progress-bar::-webkit-progress-bar { background-color: #374151; border-radius: 9999px; }
        #contextual-progress-bar::-webkit-progress-value { background-color: #3b82f6; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        #contextual-progress-bar::-moz-progress-bar { background-color: #3b82f6; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        
        #stats-popover { position: absolute; background-color: rgba(30, 41, 59, 0.9); backdrop-filter: blur(12px); border: 1px solid #4b5563; border-radius: 0.75rem; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.5); z-index: 70; width: 320px; padding: 1rem; transition: opacity 0.2s ease-out, transform 0.2s ease-out; transform-origin: top center; opacity: 0; transform: scale(0.95) translateY(-10px); pointer-events: none; }
        #stats-popover.visible { opacity: 1; transform: scale(1) translateY(0); pointer-events: auto; }
        .stat-item-enhanced { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .stat-item-enhanced .label { font-size: 0.875rem; color: #d1d5db; display: flex; align-items: center;}
        .stat-item-enhanced .value { font-size: 1rem; font-weight: 600; color: #fff; display: flex; align-items: center; }
        .performance-indicator { font-size: 0.75rem; padding: 2px 6px; border-radius: 99px; font-weight: bold; }
        .performance-indicator.up { background-color: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .performance-indicator.down { background-color: rgba(248, 113, 113, 0.2); color: #f87171; }
        .performance-indicator.same { background-color: rgba(107, 114, 128, 0.2); color: #9ca3af; }
        .heatmap-container { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; margin-top: 0.75rem; }
        .heatmap-day-header { font-size: 0.65rem; text-align: center; color: #9ca3af; }
        .heatmap-day { width: 100%; aspect-ratio: 1/1; border-radius: 4px; background-color: #374151; transition: transform 0.2s ease-out; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: 500; color: #d1d5db; position: relative; }
        .heatmap-day:hover { transform: scale(1.15); z-index: 10; }
        button.heatmap-day { cursor: pointer; border: none; padding: 0; }
        .heatmap-day.level-0 { background-color: #374151; }
        .heatmap-day.level-1 { background-color: #1d4ed8; color: white; }
        .heatmap-day.level-2 { background-color: #2563eb; color: white; }
        .heatmap-day.level-3 { background-color: #3b82f6; color: white; }
        .heatmap-day.level-4 { background-color: #60a5fa; color: white; }
        .category-progress-item { margin-bottom: 0.5rem; } .category-progress-item .title { font-size: 0.8rem; font-weight: 500; color: #d1d5db; margin-bottom: 0.25rem; }
        .progress-bar-bg { width: 100%; height: 8px; background-color: #4b5563; border-radius: 99px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background-color: #3b82f6; border-radius: 99px; transition: width 0.5s ease-out; }
        .sparkline-container { height: 60px; position: relative; } .sparkline-svg { width: 100%; height: 100%; } .sparkline-line { fill: none; stroke: #60a5fa; stroke-width: 2; } .sparkline-fill { fill: url(#sparkline-gradient); }
        .year-highlights { display: flex; justify-content: space-between; text-align: center; margin-top: 0.5rem; } .highlight-box { padding: 0.5rem; background-color: rgba(55, 65, 81, 0.4); border-radius: 0.5rem; flex: 1; margin: 0 4px; }
        .highlight-box .label { font-size: 0.7rem; color: #9ca3af; } .highlight-box .value { font-weight: 600; font-size: 0.9rem; color: #e5e7eb; }

        /* --- START: NEW STYLES FOR INTEGRATED ADVANCED MODAL --- */
        .modal-backdrop { position: fixed; inset: 0; background-color: rgba(17, 24, 39, 0.95); backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center; z-index: 50; overflow-y: auto; padding: 1rem; }
        .modal-backdrop.hidden { display: none; }
        input[type="time"]::-webkit-calendar-picker-indicator,
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.8); cursor: pointer; }
        
        #modal-content-wrapper { max-height: 90vh; }
        #new-task-title { caret-color: #3b82f6; }
        #new-task-description { line-height: 1.4; }
        #new-task-starred-btn.starred { color: #f59e0b; background-color: rgba(245, 158, 11, 0.1); }
        .attribute-btn { display: inline-flex; align-items: center; gap: 0.4rem; background-color: #374151; color: #d1d5db; padding: 0.3rem 0.6rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 500; border: 1px solid #4b5563; cursor: pointer; transition: all 0.2s ease-in-out; }
        .attribute-btn:hover { background-color: #4b5563; border-color: #6b7280; }
        .attribute-btn.active-popover { background-color: #1f2937; border-color: #3b82f6; color: white; }
        .attribute-btn.set { color: white; background-color: #1f2937; border-color: #4b5563; }
        .attribute-btn.priority-high { border-color: #ef4444; color: #ef4444; }
        .attribute-btn.priority-medium { border-color: #f59e0b; color: #f59e0b; }
        .attribute-btn.priority-low { border-color: #22c55e; color: #22c55e; }
        .attribute-popover { position: absolute; bottom: calc(100% + 0.5rem); background-color: #2d3748; border: 1px solid #4b5563; border-radius: 0.375rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3), 0 4px 6px -2px rgba(0,0,0,0.2); z-index: 70; width: 180px; overflow: hidden; animation: fadeIn 0.15s ease-out; }
        .popover-option { display: flex; align-items: center; gap: 0.5rem; width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; color: #d1d5db; text-align: right; }
        .popover-option:hover { background-color: #4b5563; color: white; }
        .popover-option.priority-high { color: #fca5a5; }
        .popover-option.priority-medium { color: #fed7aa; }
        .popover-option.priority-low { color: #86efac; }
        #popover-category-list .popover-option { justify-content: space-between; }
        .attribute-popover input, .attribute-popover select { width: 100%; background-color: #4b5563; border: 1px solid #6b7280; color: white; padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; color-scheme: dark; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        
        #toggle-advanced-countdown-btn { background-color: transparent; border: none; color: #9ca3af; cursor: pointer; padding: 0.25rem; }
        #toggle-advanced-countdown-btn:hover { color: #e5e7eb; }
        #toggle-advanced-countdown-btn.active { color: #3b82f6; }

        .attribute-popover .popover-header { display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 1rem; border-bottom: 1px solid #4b5563; background-color: rgba(75, 85, 99, 0.2); }
        .attribute-popover .popover-header h3 { font-size: 0.9rem; font-weight: 600; color: #e5e7eb; }
        .attribute-popover .popover-header i { color: #9ca3af; }
        .attribute-popover .popover-body { padding: 1rem; display: flex; flex-direction: column; gap: 1.25rem; }
        .popover-form-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .popover-form-group > label { font-size: 0.8rem; font-weight: 500; color: #d1d5db; display: flex; align-items: center; gap: 0.5rem; }
        .popover-input-group { display: flex; align-items: center; gap: 0.5rem; }
        
        .popover-main-toggle { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background-color: rgba(75, 85, 99, 0.2); border-radius: 0.375rem; }
        .popover-main-toggle label { font-size: 0.875rem; font-weight: 500; color: #e5e7eb; cursor: pointer; }
        .popover-conditional-settings { border-top: 1px solid #4b5563; margin-top: 1rem; padding-top: 1rem; display: flex; flex-direction: column; gap: 1rem; transition: opacity 0.3s ease; }
        .popover-conditional-settings.disabled { opacity: 0.5; pointer-events: none; }
        #advanced-countdown-popover .popover-form-group { flex-direction: row; justify-content: space-between; align-items: center; }
        
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #2563eb; }
        input:focus + .slider { box-shadow: 0 0 1px #2563eb; }
        input:checked + .slider:before { transform: translateX(20px); }
        .slider.round { border-radius: 34px; }
        .slider.round:before { border-radius: 50%; }
        /* --- END: NEW STYLES FOR INTEGRATED ADVANCED MODAL --- */
    </style>
</head>
<body class="font-sans">

    <div id="widget-container" class="bg-gray-900 text-white rounded-lg p-4 shadow-lg relative overflow-hidden flex flex-col h-full">
    
        <!-- Contextual Top Bar -->
        <div id="contextual-top-bar" class="flex flex-col mb-3">
            <div class="flex justify-between items-center w-full gap-2">
                <div class="flex-shrink-0">
                    <label for="hidden-date-input" id="date-display-btn" class="cursor-pointer text-lg font-bold text-gray-200 hover:text-white transition-colors flex items-center gap-2">
                        <i class="far fa-calendar-alt text-gray-400"></i>
                        <span id="date-display-text"></span>
                    </label>
                    <input type="date" id="hidden-date-input" class="hidden" style="color-scheme: dark;">
                </div>

                <div class="flex-grow flex items-center gap-2 bg-gray-800 rounded-full px-2 border border-gray-700 focus-within:border-blue-500 transition-colors">
                    <i class="fas fa-search text-gray-500 ml-2"></i>
                    <input type="search" id="search-input" placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ù‡Ø§Ù…..." class="flex-grow bg-transparent text-white text-sm focus:outline-none placeholder-gray-500 py-2" />
                    <div id="filter-dropdown-container" class="relative">
                        <button id="filter-icon-btn" aria-haspopup="true" aria-expanded="false" title="ÙÙ„Ø§ØªØ± Ù…ØªÙ‚Ø¯Ù…Ø©" class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-700 text-gray-400 hover:text-white transition-colors">
                            <i class="fas fa-filter"></i>
                        </button>
                        <div id="filter-dropdown-content" class="hidden absolute top-full left-0 mt-2">
                            <div class="mb-3">
                                <label for="category-filter-select">Ø§Ù„ÙØ¦Ø©:</label>
                                <select id="category-filter-select" class="w-full">
                                    <option value="all">ÙƒÙ„ Ø§Ù„ÙØ¦Ø§Øª</option>
                                </select>
                            </div>
                            <div>
                                <label>ÙÙ„ØªØ±Ø© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„:</label>
                                <div id="completion-filter-container" class="completion-filter-container">
                                    <button data-filter="all" class="completion-filter-btn active" title="Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ù…Ù‡Ø§Ù…"><i class="fas fa-list-ul mr-1"></i> Ø§Ù„ÙƒÙ„</button>
                                    <button data-filter="pending" class="completion-filter-btn" title="Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø¬Ø§Ø±ÙŠØ© ÙÙ‚Ø·"><i class="far fa-clock mr-1"></i> Ø¬Ø§Ø±ÙŠØ©</button>
                                    <button data-filter="completed" class="completion-filter-btn" title="Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© ÙÙ‚Ø·"><i class="fas fa-check-circle mr-1"></i> Ù…ÙƒØªÙ…Ù„Ø©</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="flex items-center pt-4 pb-2 gap-3">
                <div class="relative flex-shrink-0">
                    <div id="smart-view-switcher">
                         <button id="smart-view-switcher-dropdown-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø¹Ø±Ø¶">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                        <button id="smart-view-switcher-main">
                            <i class="fas fa-calendar-week"></i>
                            <span id="smart-view-switcher-text">Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹</span>
                        </button>
                    </div>
                    <div id="date-view-dropdown" class="hidden">
                        <button data-view="days" class="active"><i class="fas fa-calendar-day"></i> Ø´Ø±ÙŠØ· Ø§Ù„Ø£ÙŠØ§Ù…</button>
                        <button data-view="weeks"><i class="fas fa-calendar-week"></i> Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø³Ø§Ø¨ÙŠØ¹</button>
                        <button data-view="months"><i class="far fa-calendar-alt"></i> Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø´Ù‡Ø±</button>
                        <button data-view="quarters"><i class="fas fa-chart-pie"></i> Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø±Ø¨Ø§Ø¹</button>
                        <button data-view="years"><i class="fas fa-calendar"></i> Ø´Ø±ÙŠØ· Ø§Ù„Ø³Ù†ÙˆØ§Øª</button>
                    </div>
                </div>
                <div id="date-nav-container" class="flex-grow flex items-center gap-1"></div>
            </div>
            
            <div id="active-filters-container" class="flex flex-wrap gap-2 mt-2 px-1"></div>
        </div>
    
        <div class="text-sm text-gray-400 mb-2 flex justify-between items-center px-2 flex-shrink-0">
            <div class="flex items-center gap-3">
                <span id="tasks-count">Ø§Ù„Ù…Ù‡Ø§Ù… (0)</span>
                <div id="contextual-progress-container" class="flex items-center gap-2">
                    <progress id="contextual-progress-bar" class="w-20 md:w-24 h-1.5 rounded-full" max="100" value="0"></progress>
                    <span id="contextual-progress-text" class="font-mono text-xs">0%</span>
                </div>
            </div>
            <span id="stats-instruction-text" class="text-xs">Ø§Ù†Ù‚Ø± Ù„Ù„ØªØ­Ø¯ÙŠØ¯ØŒ Ø«Ù… Ø§Ù†Ù‚Ø± Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</span>
        </div>

        <div id="task-list-container" role="list" aria-label="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù‡Ø§Ù…" class="space-y-2 pr-1 pb-4 task-list flex-grow overflow-y-auto">
            <div id="no-tasks-message" class="text-center py-8 text-gray-400 hidden">
                Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ
            </div>
        </div>
    
        <button id="add-task-fab" title="Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        </button>
        
        <!-- START: NEW INTEGRATED MODAL -->
        <div id="add-task-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            <div id="modal-content-wrapper" class="bg-gray-800 rounded-lg w-11/12 max-w-lg shadow-2xl flex flex-col transition-all duration-300 ease-out">
                
                <form id="add-task-form" novalidate class="flex flex-col flex-grow">
                    <!-- Main Input Area -->
                    <div class="p-4" id="modal-main-input-area">
                        <div class="flex items-start gap-3">
                            <input id="new-task-completed-dummy" type="checkbox" class="w-5 h-5 rounded-sm mt-1.5 flex-shrink-0 bg-gray-700 border-gray-600" disabled>
                            <div class="flex-grow">
                                <input id="new-task-title" type="text" class="w-full bg-transparent text-lg text-gray-100 focus:outline-none placeholder-gray-500" placeholder="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø©..." required aria-required="true">
                                <textarea id="new-task-description" rows="1" class="w-full bg-transparent text-sm text-gray-400 focus:outline-none mt-1 resize-none" placeholder="Ø£Ø¶Ù ÙˆØµÙÙ‹Ø§ Ø£Ùˆ Ù…Ù„Ø§Ø­Ø¸Ø§Øª..."></textarea>
                            </div>
                            <button type="button" id="new-task-starred-btn" class="w-8 h-8 flex items-center justify-center rounded-full text-gray-500 hover:bg-gray-700 hover:text-yellow-400 transition-colors flex-shrink-0" title="ØªÙ…ÙŠÙŠØ² Ø¨Ù†Ø¬Ù…Ø©">
                                <i class="far fa-star text-lg"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Subtasks Area -->
                    <div class="px-4 pb-2" id="modal-subtasks-area">
                        <div id="subtasks-container" class="space-y-2 max-h-40 overflow-y-auto pr-2">
                            <!-- Subtasks will be rendered here by JS -->
                        </div>
                        <div class="flex items-center mt-2">
                             <i class="fas fa-plus text-gray-500 ml-3"></i>
                            <input id="new-subtask-input" type="text" class="flex-grow bg-transparent text-sm text-white focus:outline-none placeholder-gray-500" placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© ÙØ±Ø¹ÙŠØ©...">
                        </div>
                    </div>
                    
                    <!-- START: M1: Key Results for Monthly View -->
                    <div id="new-task-monthly-key-results-wrapper" class="px-4 pb-4 hidden">
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm text-gray-400 font-semibold">
                                <i class="fas fa-key ml-1"></i> Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Key Results)
                            </label>
                            <button type="button" id="add-key-result-btn" class="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded-full">+ Ø¥Ø¶Ø§ÙØ© Ù†ØªÙŠØ¬Ø©</button>
                        </div>
                        <div id="key-results-container" class="space-y-2 max-h-40 overflow-y-auto pr-2">
                            <!-- Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù‡Ù†Ø§ -->
                        </div>
                    </div>
                    <!-- END: M1: Key Results for Monthly View -->

                    <!-- START: M2 & M3: Quarterly & Yearly Goal Fields -->
                    <div id="advanced-goal-fields-container" class="px-4 pb-4 space-y-4">
                        <!-- Quarterly Fields -->
                        <div id="new-task-quarterly-metrics-wrapper" class="hidden">
                            <label for="new-task-quarterly-metrics" class="block text-sm text-gray-400 mb-1 font-semibold">
                                <i class="fas fa-chart-line ml-1"></i> Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¬Ø§Ø­
                            </label>
                            <textarea id="new-task-quarterly-metrics" rows="2" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Ù…Ø«Ø§Ù„: Ø²ÙŠØ§Ø¯Ø© Ø±Ø¶Ø§ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø¨Ù†Ø³Ø¨Ø© 15%"></textarea>
                        </div>
                        <div id="new-task-quarterly-status-wrapper" class="hidden">
                            <label for="new-task-quarterly-status" class="block text-sm text-gray-400 mb-1 font-semibold">
                                <i class="fas fa-signal ml-1"></i> Ø§Ù„Ø­Ø§Ù„Ø©
                            </label>
                            <select id="new-task-quarterly-status" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-blue-500">
                                <option value="not_started">Ù„Ù… ÙŠØ¨Ø¯Ø£ Ø¨Ø¹Ø¯ âšªï¸</option>
                                <option value="on_track">Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­ âœ…</option>
                                <option value="at_risk">Ù…Ø¹Ø±Ø¶ Ù„Ù„Ø®Ø·Ø± âš ï¸</option>
                                <option value="off_track">Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…Ø³Ø§Ø± âŒ</option>
                            </select>
                        </div>
                        <!-- Yearly Fields -->
                        <div id="new-task-yearly-domain-wrapper" class="hidden">
                            <label for="new-task-yearly-domain" class="block text-sm text-gray-400 mb-1 font-semibold">Ù…Ø¬Ø§Ù„ Ø§Ù„Ø­ÙŠØ§Ø©</label>
                            <select id="new-task-yearly-domain" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-blue-500">
                                <option value="work">Ø§Ù„Ø¹Ù…Ù„ ÙˆØ§Ù„Ù…Ù‡Ù†Ø© ğŸ¢</option>
                                <option value="health">Ø§Ù„ØµØ­Ø© ÙˆØ§Ù„Ù„ÙŠØ§Ù‚Ø© â¤ï¸</option>
                                <option value="finance">Ø§Ù„Ù…Ø§Ù„ÙŠØ© ğŸ’°</option>
                                <option value="relationships">Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦</option>
                                <option value="personal_growth">Ø§Ù„ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠ ğŸ§ </option>
                                <option value="hobbies">Ø§Ù„ØªØ±ÙÙŠÙ‡ ÙˆØ§Ù„Ù‡ÙˆØ§ÙŠØ§Øª ğŸ¨</option>
                            </select>
                        </div>
                        <div id="new-task-yearly-icon-wrapper" class="hidden">
                            <label for="new-task-yearly-icon" class="block text-sm text-gray-400 mb-1 font-semibold">Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù‡Ø¯Ù</label>
                            <select id="new-task-yearly-icon" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-blue-500">
                                <option>ğŸ¯</option> <option>ğŸš€</option> <option>ğŸ†</option> <option>ğŸ’¡</option> <option>ğŸ“š</option> <option>ğŸ“ˆ</option> <option>â¤ï¸</option> <option>ğŸ’°</option>
                            </select>
                        </div>
                        <div id="new-task-yearly-why-wrapper" class="hidden">
                            <label for="new-task-yearly-why" class="block text-sm text-gray-400 mb-1 font-semibold">Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ø§ Ø§Ù„Ù‡Ø¯Ù Ù…Ù‡Ù…ØŸ</label>
                            <textarea id="new-task-yearly-why" rows="2" class="w-full bg-gray-700 rounded p-2 text-white" placeholder="Ø§ÙƒØªØ¨ Ø¯Ø§ÙØ¹Ùƒ Ø§Ù„Ø´Ø®ØµÙŠ Ù„ØªØ­Ù‚ÙŠÙ‚ Ù‡Ø°Ø§ Ø§Ù„Ù‡Ø¯Ù..."></textarea>
                        </div>
                    </div>
                    <!-- END: M2 & M3: Quarterly & Yearly Goal Fields -->

                    <!-- START: M4: Blocker & Review Checkboxes -->
                    <div id="modal-task-actions-bar" class="px-4 pb-2 flex items-center justify-start gap-4">
                        <div id="new-task-weekly-review-wrapper" class="flex items-center hidden">
                            <input id="new-task-weekly-review" type="checkbox" class="w-5 h-5 rounded-sm bg-gray-700 border-gray-500 cursor-pointer accent-blue-500">
                            <label for="new-task-weekly-review" class="mr-2 cursor-pointer text-sm">
                                <i class="fas fa-clipboard-check text-green-400 ml-1"></i> ÙŠØªØ·Ù„Ø¨ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
                            </label>
                        </div>
                    </div>
                    <!-- END: M4: Blocker & Review Checkboxes -->

                    <!-- Attributes Bar & Footer -->
                    <div class="mt-auto bg-gray-900/50 p-2 border-t border-gray-700">
                        <div class="flex justify-between items-center">
                            <!-- Left: Attributes Toolbar -->
                            <div id="modal-attributes-bar" class="flex items-center gap-1 flex-wrap">
                                <button type="button" id="set-date-btn" class="attribute-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø±ÙŠØ®">
                                    <i class="far fa-calendar-alt"></i><span class="btn-text">Ø§Ù„ÙŠÙˆÙ…</span>
                                </button>
                                <button type="button" id="set-priority-btn" class="attribute-btn" data-priority="medium" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©">
                                    <i class="far fa-flag"></i><span class="btn-text">Ù…ØªÙˆØ³Ø·Ø©</span>
                                </button>
                                <button type="button" id="set-category-btn" class="attribute-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØ¦Ø©">
                                    <i class="fas fa-tag"></i><span class="btn-text">Ø¹Ø§Ù…</span>
                                </button>
                                <button type="button" id="set-recurrence-btn" class="attribute-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙƒØ±Ø§Ø±">
                                    <i class="fas fa-redo-alt"></i><span class="btn-text">Ù„Ø§ ÙŠØªÙƒØ±Ø±</span>
                                </button>
                                <div class="inline-flex items-center">
                                    <button type="button" id="set-time-btn" class="attribute-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª" style="border-left: none; border-top-left-radius: 0; border-bottom-left-radius: 0;">
                                        <i class="far fa-clock"></i><span class="btn-text">Ø§Ù„ÙˆÙ‚Øª</span>
                                    </button>
                                    <button type="button" id="set-duration-btn" class="attribute-btn" title="ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¯Ø©" style="border-right: 1px solid #4b5563; border-top-right-radius: 0; border-bottom-right-radius: 0;">
                                        <i class="fas fa-stopwatch"></i><span class="btn-text">Ø§Ù„Ù…Ø¯Ø©</span>
                                    </button>
                                    <button type="button" id="toggle-advanced-countdown-btn" class="ml-1 hidden" title="Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø¯ Ø§Ù„ØªÙ†Ø§Ø²Ù„ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            <!-- Right: Action Buttons -->
                            <div class="flex items-center">
                                <button type="button" id="modal-cancel-btn" class="text-gray-400 hover:text-white px-4 py-2 text-sm">Ø¥Ù„ØºØ§Ø¡</button>
                                <button type="submit" id="modal-add-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-md text-sm font-semibold disabled:opacity-50 disabled:cursor-not-allowed">Ø¥Ø¶Ø§ÙØ©</button>
                            </div>
                        </div>
                    </div>
                </form>

                <!-- Popovers container -->
                <div id="modal-popovers" class="relative">
                    <!-- Priority Popover -->
                    <div id="priority-popover" class="attribute-popover hidden">
                        <button data-value="high" class="popover-option priority-high"><i class="fas fa-flag"></i> Ø¹Ø§Ù„ÙŠØ©</button>
                        <button data-value="medium" class="popover-option priority-medium"><i class="fas fa-flag"></i> Ù…ØªÙˆØ³Ø·Ø©</button>
                        <button data-value="low" class="popover-option priority-low"><i class="fas fa-flag"></i> Ù…Ù†Ø®ÙØ¶Ø©</button>
                    </div>
                    <!-- Category Popover -->
                    <div id="category-popover" class="attribute-popover hidden p-2">
                         <input type="text" id="popover-category-input" class="w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm mb-2" placeholder="Ø§Ø¨Ø­Ø« Ø£Ùˆ Ø£Ø¶Ù ÙØ¦Ø©...">
                         <div id="popover-category-list" class="max-h-32 overflow-y-auto"></div>
                    </div>
                    <!-- Time Popover -->
                    <div id="time-popover" class="attribute-popover hidden p-2">
                        <input type="time" id="popover-time-input">
                    </div>
                    <!-- Duration Popover -->
                    <div id="duration-popover" class="attribute-popover hidden p-2 space-y-2">
                        <input type="number" id="popover-duration-value" min="1" placeholder="Ù…Ø«Ø§Ù„: 25">
                        <select id="popover-duration-unit">
                            <option value="minutes">Ø¯Ù‚Ø§Ø¦Ù‚</option>
                            <option value="hours">Ø³Ø§Ø¹Ø§Øª</option>
                            <option value="days">Ø£ÙŠØ§Ù… Ø¬Ù‡Ø¯</option>
                        </select>
                    </div>
                    <!-- Recurrence Popover -->
                    <div id="recurrence-popover" class="attribute-popover hidden">
                        <button data-value="none" class="popover-option"><i class="fas fa-ban"></i> Ù„Ø§ ÙŠØªÙƒØ±Ø±</button>
                        <button data-value="daily" class="popover-option"><i class="fas fa-calendar-day"></i> ÙŠÙˆÙ…ÙŠÙ‹Ø§</button>
                        <button data-value="weekly" class="popover-option"><i class="fas fa-calendar-week"></i> Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ‹Ø§</button>
                        <button data-value="monthly" class="popover-option"><i class="fas fa-calendar-alt"></i> Ø´Ù‡Ø±ÙŠÙ‹Ø§</button>
                    </div>
                    <!-- Advanced Countdown Settings Popover -->
                    <div id="advanced-countdown-popover" class="attribute-popover hidden p-0" style="width: 310px;">
                        <div class="popover-header">
                            <i class="fas fa-cog"></i>
                            <h3>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¤Ù‚Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</h3>
                        </div>
                        <div class="popover-body">
                            <div class="popover-main-toggle">
                                <label for="new-task-show-countdown-timer">ØªÙ…ÙƒÙŠÙ† Ù…Ø¤Ù‚Øª Ø§Ù„Ø¹Ø¯ Ø§Ù„ØªÙ†Ø§Ø²Ù„ÙŠ</label>
                                <label class="switch">
                                    <input id="new-task-show-countdown-timer" type="checkbox">
                                    <span class="slider round"></span>
                                </label>
                            </div>
                            <div class="popover-conditional-settings">
                                <div class="popover-form-group">
                                    <label for="new-task-countdown-threshold-value"><i class="far fa-bell fa-fw"></i> ØªÙ…ÙŠÙŠØ² Ø¹Ù†Ø¯ ØªØ¨Ù‚Ù‰ Ø£Ù‚Ù„ Ù…Ù†:</label>
                                    <div class="popover-input-group">
                                        <input id="new-task-countdown-threshold-value" type="number" min="1" max="999" placeholder="4">
                                        <select id="new-task-countdown-threshold-unit" class="text-sm">
                                            <option value="hours">Ø³Ø§Ø¹Ø©</option>
                                            <option value="minutes">Ø¯Ù‚ÙŠÙ‚Ø©</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="popover-form-group">
                                    <label for="new-task-auto-start-timer"><i class="far fa-play-circle fa-fw"></i> Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¤Ù‚Øª ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</label>
                                    <label class="switch">
                                        <input id="new-task-auto-start-timer" type="checkbox">
                                        <span class="slider round"></span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- END: NEW INTEGRATED MODAL -->
    
        <div class="mt-6 pt-4 border-t border-gray-700 flex justify-center flex-shrink-0">
            <div class="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white" aria-hidden="true"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><path d="m9 12 2 2 4-4"></path></svg>
            </div>
        </div>
    
        <div id="action-snackbar">
            <span id="action-snackbar-message"></span>
            <button type="button" id="action-snackbar-btn" title="ØªØ±Ø§Ø¬Ø¹"><i class="fas fa-undo-alt"></i></button>
        </div>
    </div>

    <div id="reschedule-flyout" class="hidden"></div>
    <input type="date" id="hidden-task-reschedule-picker" class="hidden" style="color-scheme: dark;">
    <input type="date" id="hidden-date-picker-input" style="position: absolute; left: -9999px; top: -9999px; opacity: 0; pointer-events: none;">

    <div id="stats-popover">
        <div class="flex justify-between items-center mb-3 pb-2 border-b border-gray-700">
            <h4 id="stats-popover-title" class="font-bold text-white text-base"></h4>
            <button id="stats-popover-close" class="text-gray-500 hover:text-white text-2xl leading-none">&times;</button>
        </div>
        <div id="stats-popover-content"></div>
    </div>

    <script>
        // --- CONSTANTS & CONFIGURATION ---
        const LOCAL_STORAGE_KEY = 'widgetTasks_scoped_v23_stats_integrated'; 
        const LOCAL_STORAGE_SETTINGS_KEY = 'widgetTaskSettings_simplified_v1_adv';
        const LOCAL_STORAGE_CATEGORIES_KEY = 'widgetTaskCategories_v2_dynamic';
        const LOCAL_STORAGE_SAVED_CATEGORIES_KEY = 'widgetTaskSavedCategories_v1';
        const DEFAULT_CATEGORY = "Ø¹Ø§Ù…";
        const MAX_TASK_DURATION_MINUTES = 1440;
        const MAX_MOST_USED_CATEGORIES = 3;

        const RESCHEDULE_OPTIONS = {
            days: [ { label: 'Ø¥Ù„Ù‰ Ø§Ù„ØºØ¯', icon: 'fas fa-sun', period: 'tomorrow' }, { label: '+ ÙŠÙˆÙ…Ø§Ù†', icon: 'fas fa-angle-double-right', period: 'plus_two_days' }, { label: 'Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-calendar-week', period: 'next_week' }, { label: 'Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ®...', icon: 'far fa-calendar-check', period: 'pick_date' } ],
            weeks: [ { label: 'Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-calendar-week', period: 'next_week' }, { label: 'Ø¨Ø¹Ø¯ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†', icon: 'fas fa-forward', period: 'plus_two_weeks' }, { label: 'Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'far fa-calendar-alt', period: 'next_month' }, { label: 'Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ®...', icon: 'far fa-calendar-check', period: 'pick_date' } ],
            months: [ { label: 'Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'far fa-calendar-alt', period: 'next_month' }, { label: 'Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-chart-pie', period: 'next_quarter' }, { label: 'Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ®...', icon: 'far fa-calendar-check', period: 'pick_date' } ],
            quarters: [ { label: 'Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-chart-pie', period: 'next_quarter' }, { label: 'Ø¨Ø¹Ø¯ Ø±Ø¨Ø¹ÙŠÙ†', icon: 'fas fa-forward', period: 'plus_two_quarters' }, { label: 'Ø§Ù„Ø¹Ø§Ù… Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-calendar', period: 'next_year' }, { label: 'Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ®...', icon: 'far fa-calendar-check', period: 'pick_date' } ],
            years: [ { label: 'Ø§Ù„Ø¹Ø§Ù… Ø§Ù„Ù‚Ø§Ø¯Ù…', icon: 'fas fa-calendar', period: 'next_year' }, { label: 'Ø¨Ø¹Ø¯ Ø¹Ø§Ù…ÙŠÙ†', icon: 'fas fa-forward', period: 'plus_two_years' }, { label: 'Ø§Ø®ØªÙŠØ§Ø± ØªØ§Ø±ÙŠØ®...', icon: 'far fa-calendar-check', period: 'pick_date' } ]
        };
        const VIEW_MODE_CONFIG = {
            days: { modalTitle: "Ù…Ù‡Ù…Ø© ÙŠÙˆÙ…ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©", placeholder: "Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©...", editTitle: "ØªØ¹Ø¯ÙŠÙ„ Ù…Ù‡Ù…Ø© ÙŠÙˆÙ…ÙŠØ©", noTasksMessage: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…" },
            weeks: { modalTitle: "Ù…Ù‡Ù…Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©", placeholder: "Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©...", editTitle: "ØªØ¹Ø¯ÙŠÙ„ Ù…Ù‡Ù…Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©", noTasksMessage: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹" },
            months: { modalTitle: "Ù‡Ø¯Ù Ø´Ù‡Ø±ÙŠ Ø¬Ø¯ÙŠØ¯", placeholder: "Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ...", editTitle: "ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø¯Ù Ø´Ù‡Ø±ÙŠ", noTasksMessage: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±" },
            quarters: { modalTitle: "Ù‡Ø¯Ù Ø±Ø¨Ø¹ Ø³Ù†ÙˆÙŠ Ø¬Ø¯ÙŠØ¯", placeholder: "Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø±Ø¨Ø¹ Ø³Ù†ÙˆÙŠ...", editTitle: "ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø¯Ù Ø±Ø¨Ø¹ Ø³Ù†ÙˆÙŠ", noTasksMessage: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø±Ø¨Ø¹" },
            years: { modalTitle: "Ù‡Ø¯Ù Ø³Ù†ÙˆÙŠ Ø¬Ø¯ÙŠØ¯", placeholder: "Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø³Ù†ÙˆÙŠ...", editTitle: "ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø¯Ù Ø³Ù†ÙˆÙŠ", noTasksMessage: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø³Ù†Ø©" }
        };
        const PRIORITY_MAP = { high: { text: "Ø¹Ø§Ù„ÙŠØ©", icon: "fas fa-flag", class: "priority-high" }, medium: { text: "Ù…ØªÙˆØ³Ø·Ø©", icon: "far fa-flag", class: "priority-medium" }, low: { text: "Ù…Ù†Ø®ÙØ¶Ø©", icon: "far fa-flag", class: "priority-low" } };
        const RECURRENCE_MAP = { none: { text: "Ù„Ø§ ÙŠØªÙƒØ±Ø±" }, daily: { text: "ÙŠÙˆÙ…ÙŠÙ‹Ø§" }, weekly: { text: "Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ‹Ø§" }, monthly: { text: "Ø´Ù‡Ø±ÙŠÙ‹Ø§" } };
        const HIERARCHY_LEVELS = {
            days: { level: 0, label: "ÙŠÙˆÙ…ÙŠ", icon: "fas fa-calendar-day", parent: "weeks", child: null },
            weeks: { level: 1, label: "Ø£Ø³Ø¨ÙˆØ¹ÙŠ", icon: "fas fa-calendar-week", parent: "months", child: "days" },
            months: { level: 2, label: "Ø´Ù‡Ø±ÙŠ", icon: "fas fa-calendar-alt", parent: "quarters", child: "weeks" },
            quarters: { level: 3, label: "Ø±Ø¨Ø¹ÙŠ", icon: "fas fa-chart-pie", parent: "years", child: "months" },
            years: { level: 4, label: "Ø³Ù†ÙˆÙŠ", icon: "fas fa-calendar", parent: null, child: "quarters" }
        };
        const ARABIC_MONTHS = ["ÙŠÙ†Ø§ÙŠØ±", "ÙØ¨Ø±Ø§ÙŠØ±", "Ù…Ø§Ø±Ø³", "Ø¥Ø¨Ø±ÙŠÙ„", "Ù…Ø§ÙŠÙˆ", "ÙŠÙˆÙ†ÙŠÙˆ", "ÙŠÙˆÙ„ÙŠÙˆ", "Ø£ØºØ³Ø·Ø³", "Ø³Ø¨ØªÙ…Ø¨Ø±", "Ø£ÙƒØªÙˆØ¨Ø±", "Ù†ÙˆÙÙ…Ø¨Ø±", "Ø¯ÙŠØ³Ù…Ø¨Ø±"];
        const ARABIC_QUARTERS = ["Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø£ÙˆÙ„", "Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø«Ø§Ù†ÙŠ", "Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø«Ø§Ù„Ø«", "Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø±Ø§Ø¨Ø¹"];
        const WEEK_DAYS_ARABIC = ["Ø§Ù„Ø£Ø­Ø¯", "Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†", "Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡", "Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø§Ù„Ø®Ù…ÙŠØ³", "Ø§Ù„Ø¬Ù…Ø¹Ø©", "Ø§Ù„Ø³Ø¨Øª"];
        const WEEK_DAYS_SHORT_ARABIC = ["Ø­", "Ù†", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"];
        const VIEW_HIERARCHY = {
            levels: ['days', 'weeks', 'months', 'quarters', 'years'],
            labels: { days: 'ÙŠÙˆÙ…ÙŠ', weeks: 'Ø£Ø³Ø¨ÙˆØ¹ÙŠ', months: 'Ø´Ù‡Ø±ÙŠ', quarters: 'Ø±Ø¨Ø¹ Ø³Ù†ÙˆÙŠ', years: 'Ø³Ù†ÙˆÙŠ' },
            nextLabels: { days: 'Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹', weeks: 'Ø§Ù„Ø´Ù‡Ø±', months: 'Ø§Ù„Ø±Ø¨Ø¹', quarters: 'Ø§Ù„Ø³Ù†Ø©', years: 'Ø§Ù„ÙŠÙˆÙ…' },
             nextIcons: { days: 'fa-calendar-week', weeks: 'fa-calendar-alt', months: 'fa-chart-pie', quarters: 'fa-calendar', years: 'fa-calendar-day' }
        };
        const SWIPE_THRESHOLD = 50;
        const SWIPE_MAX_TRANSLATE = 80;
        const UNDO_TIMEOUT = 6000;
        const MAX_RECURRENCE_CHECKS = 1000;
        const COUNTDOWN_UPDATE_INTERVAL = 30000;
        const TASK_TIMER_UPDATE_INTERVAL = 1000;
        const TIMER_ALMOST_DONE_THRESHOLD_SECONDS = 60;
        const INFO_SNACKBAR_TIMEOUT = 4000; 

        const StatsCalculator = {
            calculateForPeriod(period, date) { const currentRange = this.helpers.getDateRange(period, date); const previousRange = this.helpers.getPreviousDateRange(period, date); const allTasksInPeriod = tasks.filter(t => new Date(t.date) >= currentRange.start && new Date(t.date) <= currentRange.end); const completedTasks = tasks.filter(t => t.completed && t.completedAt && new Date(t.completedAt) >= currentRange.start && new Date(t.completedAt) <= currentRange.end); const prevCompletedTasks = tasks.filter(t => t.completed && t.completedAt && new Date(t.completedAt) >= previousRange.start && new Date(t.completedAt) <= previousRange.end); const performanceIndicator = this.helpers.getPerformanceIndicator(completedTasks.length, prevCompletedTasks.length); let specificData = {}; if (period === 'days' || period === 'weeks') { specificData.focusTime = this.helpers.calculateFocusTime(completedTasks); specificData.topCategory = this.helpers.findTopCategory(completedTasks); } if (period === 'months') { specificData.heatmapData = this.helpers.getHeatmapData(completedTasks, currentRange.start); specificData.streak = this.helpers.calculateStreak(completedTasks, currentRange); } if (period === 'quarters') { specificData.categoryProgress = this.helpers.getCategoryProgress(allTasksInPeriod); } if (period === 'years') { const monthlyData = this.helpers.getMonthlyCompletionData(completedTasks, currentRange.start.getFullYear()); specificData.monthlyCompletionData = monthlyData; specificData.yearHighlights = this.helpers.getYearHighlights(completedTasks, monthlyData); } return { totalTasks: allTasksInPeriod.length, completedCount: completedTasks.length, performanceIndicator, ...specificData }; },
            helpers: {
                getDateRange(period, date) { const d = new Date(date); let start, end; switch (period) { case 'days': start = new Date(d.setHours(0,0,0,0)); end = new Date(d.setHours(23,59,59,999)); break; case 'weeks': start = getStartOfWeek(d); end = new Date(start); end.setDate(start.getDate()+6); end.setHours(23,59,59,999); break; case 'months': start = new Date(d.getFullYear(),d.getMonth(),1); end = new Date(d.getFullYear(),d.getMonth()+1,0,23,59,59,999); break; case 'quarters': const q = Math.floor(d.getMonth()/3); start = new Date(d.getFullYear(),q*3,1); end = new Date(d.getFullYear(),q*3+3,0,23,59,59,999); break; case 'years': start = new Date(d.getFullYear(),0,1); end = new Date(d.getFullYear(),11,31,23,59,59,999); break; } return { start, end }; },
                getPreviousDateRange(period, date) { const d = new Date(date); switch (period) { case 'days': d.setDate(d.getDate() - 1); break; case 'weeks': d.setDate(d.getDate() - 7); break; case 'months': d.setMonth(d.getMonth() - 1); break; case 'quarters': d.setMonth(d.getMonth() - 3); break; case 'years': d.setFullYear(d.getFullYear() - 1); break; } return this.getDateRange(period, d); },
                getPerformanceIndicator(current, previous) { const diff = current - previous; if (diff > 0) return { class: 'up', text: `<i class="fas fa-arrow-up"></i> +${diff}` }; if (diff < 0) return { class: 'down', text: `<i class="fas fa-arrow-down"></i> ${diff}` }; return { class: 'same', text: `<i class="fas fa-equals"></i>` }; },
                getHeatmapData(completedTasks, monthStartDate) { const year = monthStartDate.getFullYear(); const month = monthStartDate.getMonth(); const daysInMonth = new Date(year, month + 1, 0).getDate(); const firstDayOfWeek = new Date(year, month, 1).getDay(); let dailyCounts = Array(daysInMonth + 1).fill(0); completedTasks.forEach(task => { const completedDate = new Date(task.completedAt); if (completedDate.getFullYear() === year && completedDate.getMonth() === month) { dailyCounts[completedDate.getDate()]++ }}); const maxCount = Math.max(1, ...dailyCounts); let heatmap = Array(firstDayOfWeek).fill({ day: null, level: 0, title: '' }); for (let day = 1; day <= daysInMonth; day++) { const count = dailyCounts[day]; heatmap.push({ day: day, level: count > 0 ? Math.ceil((count / maxCount) * 4) : 0, title: `${day}/${month + 1}: ${count} ${count === 1 ? 'Ù…Ù‡Ù…Ø©' : 'Ù…Ù‡Ø§Ù…'}` }); } return heatmap; },
                getCategoryProgress(tasksInQuarter) { const categoryData = tasksInQuarter.reduce((acc, task) => { const cat = task.category || 'Ø¹Ø§Ù…'; if (!acc[cat]) acc[cat] = { total: 0, completed: 0 }; acc[cat].total++; if (task.completed) acc[cat].completed++; return acc; }, {}); return Object.entries(categoryData).sort(([, a], [, b]) => b.total - a.total).slice(0, 3).map(([category, data]) => ({ category, ...data, percentage: data.total > 0 ? (data.completed / data.total) * 100 : 0 })); },
                getMonthlyCompletionData: (tasks, year) => Array.from({ length: 12 }, (_, month) => tasks.filter(t => t.completedAt && new Date(t.completedAt).getFullYear() === year && new Date(t.completedAt).getMonth() === month).length),
                getYearHighlights(completedTasks, monthlyData) { if (completedTasks.length === 0) { return { bestMonth: 'Ù„Ø§ ÙŠÙˆØ¬Ø¯', topCategory: 'Ù„Ø§ ÙŠÙˆØ¬Ø¯' }; } const bestMonthIndex = monthlyData.indexOf(Math.max(...monthlyData)); const categoryCounts = completedTasks.reduce((acc, task) => { const cat = task.category || 'Ø¹Ø§Ù…'; acc[cat] = (acc[cat] || 0) + 1; return acc; }, {}); const topCategory = Object.keys(categoryCounts).length > 0 ? Object.entries(categoryCounts).sort(([, a], [, b]) => b - a)[0][0] : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'; return { bestMonth: ARABIC_MONTHS[bestMonthIndex], topCategory }; },
                calculateFocusTime(completedTasks) { const totalMinutes = completedTasks.reduce((acc, task) => { if (!task.duration || !task.duration.value) return acc; if (task.duration.unit === 'minutes') return acc + task.duration.value; if (task.duration.unit === 'hours') return acc + (task.duration.value * 60); return acc; }, 0); if (totalMinutes === 0) return null; const hours = Math.floor(totalMinutes / 60); const minutes = totalMinutes % 60; let parts = []; if (hours > 0) parts.push(`${hours} Ø³`); if (minutes > 0) parts.push(`${minutes} Ø¯`); return parts.join(' '); },
                findTopCategory(completedTasks) { if (completedTasks.length === 0) return null; const counts = completedTasks.reduce((acc, task) => { const cat = task.category || 'Ø¹Ø§Ù…'; acc[cat] = (acc[cat] || 0) + 1; return acc; }, {}); return Object.entries(counts).sort(([, a], [, b]) => b - a)[0][0]; },
                calculateStreak(completedTasks) { if (completedTasks.length < 2) return completedTasks.length; const completionDates = [...new Set(completedTasks.map(t => new Date(t.completedAt).setHours(0, 0, 0, 0)))].sort(); let maxStreak = 0; let currentStreak = 0; if (completionDates.length > 0) { maxStreak = 1; currentStreak = 1; } for (let i = 1; i < completionDates.length; i++) { const diffDays = (completionDates[i] - completionDates[i - 1]) / 86400000; if (diffDays === 1) { currentStreak++; } else { maxStreak = Math.max(maxStreak, currentStreak); currentStreak = 1; } } maxStreak = Math.max(maxStreak, currentStreak); return maxStreak; }
            }
        };
        
        const AdvancedStatsHandler = {
            popoverEl: null, titleEl: null, contentEl: null, statsCache: new Map(),
            init() { this.popoverEl = document.getElementById('stats-popover'); this.titleEl = document.getElementById('stats-popover-title'); this.contentEl = document.getElementById('stats-popover-content'); document.getElementById('stats-popover-close')?.addEventListener('click', () => this.hide()); },
            showForElement(positioningElement, period, date) { if (!date) return; const cacheKey = `${period}-${date.getTime()}`; let statsData = this.statsCache.get(cacheKey); if (!statsData) { statsData = StatsCalculator.calculateForPeriod(period, date); this.statsCache.set(cacheKey, statsData); } this.titleEl.textContent = this.getTitleForPeriod(period, date); this.contentEl.innerHTML = StatsRenderer.render(period, statsData, date); const rect = positioningElement.getBoundingClientRect(); this.popoverEl.style.left = `${Math.max(10, Math.min(window.innerWidth - 330, rect.left + window.scrollX - (this.popoverEl.offsetWidth / 2) + (rect.width / 2)))}px`; this.popoverEl.style.top = `${rect.bottom + window.scrollY + 8}px`; this.popoverEl.classList.add('visible'); if (period === 'months') { this.attachHeatmapClickListener(); } },
            hide() { if (this.popoverEl) this.popoverEl.classList.remove('visible'); },
            isVisible() { return this.popoverEl && this.popoverEl.classList.contains('visible'); },
            getTitleForPeriod(period, date) { switch (period) { case 'days': return `Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ${date.toLocaleDateString('ar-EG', { day: 'numeric', month: 'long' })}`; case 'weeks': return `Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${getWeekNumber(date)[1]}`; case 'months': return `Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ${ARABIC_MONTHS[date.getMonth()]}`; case 'quarters': return `Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ${ARABIC_QUARTERS[Math.floor(date.getMonth() / 3)]}`; case 'years': return `Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø³Ù†Ø© ${date.getFullYear()}`; default: return "Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"; } },
            attachHeatmapClickListener() { const container = this.contentEl.querySelector('#heatmap-interactive-container'); if (!container) return; container.addEventListener('click', (e) => { const dayButton = e.target.closest('.heatmap-day[data-date]'); if (!dayButton) return; const dateStr = dayButton.dataset.date; const targetDate = parseDateInput(dateStr); this.hide(); changeViewMode('days'); Object.keys(viewDates).forEach(key => viewDates[key] = new Date(targetDate)); renderApp(); }); }
        };

        const StatsRenderer = {
            render(period, data, date) { const isDataEmpty = (data.totalTasks === 0 && data.completedCount === 0); if (isDataEmpty) { return this.renderEmptyState(); } switch (period) { case 'days': case 'weeks': return this.renderDayWeekStats(data); case 'months': return this.renderMonthStats(data, date); case 'quarters': return this.renderQuarterStats(data); case 'years': return this.renderYearStats(data); default: return `<div class="text-center text-gray-400 p-4">Ø®Ø·Ø£: Ù†Ø·Ø§Ù‚ Ø²Ù…Ù†ÙŠ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.</div>`; } },
            renderEmptyState() { return `<div class="text-center text-gray-400 p-4 flex flex-col items-center gap-3"><i class="fas fa-info-circle fa-2x text-gray-500"></i><p class="text-sm">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù‡Ø§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.</p></div>`; },
            renderDayWeekStats(data) { let html = `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-check-circle text-green-400 mr-2"></i>Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©</span><div class="value"><span>${data.completedCount} / ${data.totalTasks}</span><span class="performance-indicator ${data.performanceIndicator.class} mr-2">${data.performanceIndicator.text}</span></div></div>`; if (data.focusTime) { html += `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-stopwatch text-blue-400 mr-2"></i>ÙˆÙ‚Øª Ø§Ù„ØªØ±ÙƒÙŠØ²</span><span class="value">${data.focusTime}</span></div>`; } if (data.topCategory) { html += `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-tags text-purple-400 mr-2"></i>Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø¨Ø±Ø²</span><span class="value">${data.topCategory}</span></div>`; } return html; },
            renderMonthStats(data, monthStartDate) { const dayHeaders = ['Ø­', 'Ù†', 'Ø«', 'Ø±', 'Ø®', 'Ø¬', 'Ø³'].map(d => `<div class="heatmap-day-header">${d}</div>`).join(''); const heatmapCells = data.heatmapData.map(d => { if (d.day === null) { return `<div class="heatmap-day level-0"></div>`; } const cellDate = new Date(monthStartDate.getFullYear(), monthStartDate.getMonth(), d.day); const dateString = formatDateForInput(cellDate); return `<button class="heatmap-day level-${d.level}" title="${d.title}" data-date="${dateString}">${d.day}</button>`; }).join(''); const completionRate = data.totalTasks > 0 ? Math.round((data.completedCount / data.totalTasks) * 100) : 0; let html = `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-bullseye text-green-400 mr-2"></i>Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²</span><div class="value">${completionRate}%<span class="text-xs text-gray-400 mr-2">(${data.completedCount}/${data.totalTasks})</span></div></div>`; if (data.streak > 1) { html += `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-fire text-orange-400 mr-2"></i>Ø£Ø·ÙˆÙ„ Ø³Ù„Ø³Ù„Ø© Ø¥Ù†Ø¬Ø§Ø²</span><span class="value">${data.streak} Ø£ÙŠØ§Ù…</span></div>`; } html += `<div class="mt-4 pt-3 border-t border-gray-700"><span class="label font-semibold mb-2 block"><i class="fas fa-th text-indigo-400 mr-2"></i>Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø¥Ù†ØªØ§Ø¬ÙŠØ©</span><div class="grid grid-cols-7 gap-1">${dayHeaders}</div><div class="heatmap-container" id="heatmap-interactive-container">${heatmapCells}</div></div>`; return html; },
            renderQuarterStats(data) { const categoryProgressHtml = data.categoryProgress.map(c => `<div class="category-progress-item"><div class="title flex justify-between"><span>${c.category}</span> <span class="text-xs text-gray-400">${c.completed}/${c.total}</span></div><div class="progress-bar-bg"><div class="progress-bar-fill" style="width: ${c.percentage}%;"></div></div></div>`).join(''); return `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-flag-checkered text-indigo-400 mr-2"></i>ØªÙ‚Ø¯Ù… Ø§Ù„Ø±Ø¨Ø¹</span><div class="value"><span>${data.completedCount} / ${data.totalTasks}</span><span class="performance-indicator ${data.performanceIndicator.class} mr-2">${data.performanceIndicator.text}</span></div></div><div class="mt-4 pt-3 border-t border-gray-700"><span class="label font-semibold mb-2 block"><i class="fas fa-stream text-purple-400 mr-2"></i>Ø§Ù„ØªØ±ÙƒÙŠØ² Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©</span>${categoryProgressHtml || `<div class="text-xs text-gray-500 text-center py-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙØ¦Ø§Øª ÙƒØ§ÙÙŠØ©.</div>`}</div>`; },
            renderYearStats(data) { const sparklinePath = this.helpers.createSparklinePath(data.monthlyCompletionData); return `<div class="stat-item-enhanced"><span class="label"><i class="fas fa-trophy text-yellow-400 mr-2"></i>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ø³Ù†ÙˆÙŠ</span><div class="value"><span>${data.completedCount} Ù…Ù‡Ù…Ø©</span><span class="performance-indicator ${data.performanceIndicator.class} mr-2">${data.performanceIndicator.text}</span></div></div><div class="mt-2"><div class="sparkline-container"><svg class="sparkline-svg" preserveAspectRatio="none"><defs><linearGradient id="sparkline-gradient" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#3b82f6;stop-opacity:0.5"/><stop offset="100%" style="stop-color:#3b82f6;stop-opacity:0"/></linearGradient></defs><path class="sparkline-fill" d="${sparklinePath.fill}" /><path class="sparkline-line" d="${sparklinePath.line}" /></svg></div><div class="year-highlights"><div class="highlight-box"><div class="label">Ø£ÙØ¶Ù„ Ø´Ù‡Ø±</div><div class="value">${data.yearHighlights.bestMonth}</div></div><div class="highlight-box"><div class="label">Ø£Ø¨Ø±Ø² ÙØ¦Ø©</div><div class="value">${data.yearHighlights.topCategory}</div></div></div></div>`; },
            helpers: { createSparklinePath(data) { const width = 280, height = 50; const maxVal = Math.max(...data, 1); const points = data.map((d, i) => `${(i / 11) * width},${height - (d / maxVal) * (height - 2) + 1}`); const linePath = "M" + points.join(" L"); const fillPath = linePath + ` L${width},${height} L0,${height} Z`; return { line: linePath, fill: fillPath }; } }
        };

        // --- DOM ELEMENT VARIABLES ---
        let widgetContainer, taskListContainer, tasksCountEl, noTasksMessage, searchInput, addTaskFab,
            actionSnackbar, actionSnackbarMessageEl, actionSnackbarBtn,
            filterIconBtn, filterDropdownContent, categoryFilterSelect, completionFilterContainer, 
            dateDisplayBtn, dateDisplayText, hiddenDateInput, activeFiltersContainer, 
            dateNavContainer, smartViewSwitcherMain, smartViewSwitcherDropdownBtn, smartViewSwitcherText, dateViewDropdown,
            rescheduleFlyout, hiddenReschedulePicker,
            contextualProgressContainer, contextualProgressBar, contextualProgressText,
            contextualTopBar;
        
        // --- NEW MODAL DOM ELEMENT VARIABLES ---
        let addTaskModal, addTaskForm, modalAddBtn, modalCancelBtn,
            newTaskTitleInput, newTaskDescriptionInput, newTaskStarredBtn,
            subtasksContainer, newSubtaskInput,
            setDateBtn, setPriorityBtn, setCategoryBtn, setTimeBtn, setDurationBtn,
            setRecurrenceBtn, toggleAdvancedCountdownBtn,
            hiddenDatePickerInput, priorityPopover, categoryPopover, popoverCategoryInput,
            popoverCategoryList, timePopover, popoverTimeInput, durationPopover,
            popoverDurationValue, popoverDurationUnit, recurrencePopover,
            advancedCountdownPopover, newTaskShowCountdownTimerCheckbox, 
            newTaskCountdownThresholdValueInput, newTaskCountdownThresholdUnitSelect, newTaskAutoStartTimerCheckbox;
            
        /* START: M1, M2, M3, M4 DOM Variables */
        let newTaskMonthlyKeyResultsWrapper, keyResultsContainer, addKeyResultBtn,
            newTaskQuarterlyMetricsWrapper, newTaskQuarterlyMetrics, newTaskQuarterlyStatusWrapper, newTaskQuarterlyStatus,
            newTaskYearlyDomainWrapper, newTaskYearlyDomain, newTaskYearlyIconWrapper, newTaskYearlyIcon,
            newTaskYearlyWhyWrapper, newTaskYearlyWhy,
            newTaskWeeklyReviewWrapper, newTaskWeeklyReviewCheckbox;
        /* END: M1, M2, M3, M4 DOM Variables */

        // --- STATE VARIABLES ---
        let viewDates = { days: new Date(), weeks: new Date(), months: new Date(), quarters: new Date(), years: new Date() };
        Object.values(viewDates).forEach(date => date.setHours(0,0,0,0));
        let currentDateViewMode = 'days'; 
        let selectedDateRange = { start: null, end: null }; 
        let tasks = []; 
        let editingTaskId = null; 
        let recentlyDeletedTask = null; let undoDeleteTimeoutId = null;
        let recentlyRescheduledTask = null; let undoRescheduleTimeoutId = null;
        let draggedTaskId = null; let dragOverTaskId = null;
        let swipingTaskId = null; let touchStartX = 0; let touchCurrentX = 0; let isSwiping = false; let swipePreventScroll = false; let swipeAnimationTimeout = null;
        let countdownIntervalId = null; let originalPageTitle = document.title; let notificationPermissionGranted = false;
        let currentCompletionFilter = 'all';
        let isMonthViewExpanded = false; 
        let isNavDragging = false;
        let navStartX = 0;
        let navScrollLeft = 0;
        let currentHoveredNavElement = null;
        let widgetSettings = { countdownEnabled: true, countdownSoonThresholdHours: 4 };
        let availableCategories = [];
        let savedCategories = [];
        let longPressTimer = null;
        let isLongPress = false;
        let lastClickedDateStr = null;

        // --- NEW MODAL STATE VARIABLES ---
        let currentModalState = {};
        let activePopover = null;
        /* START: M1 State Variable */
        let currentKeyResultsInModal = [];
        /* END: M1 State Variable */

        function queryDOMElements() {
            widgetContainer = document.getElementById('widget-container');
            taskListContainer = document.getElementById('task-list-container');
            tasksCountEl = document.getElementById('tasks-count');
            noTasksMessage = document.getElementById('no-tasks-message');
            searchInput = document.getElementById('search-input');
            addTaskFab = document.getElementById('add-task-fab');
            actionSnackbar = document.getElementById('action-snackbar');
            actionSnackbarMessageEl = document.getElementById('action-snackbar-message');
            actionSnackbarBtn = document.getElementById('action-snackbar-btn');
            filterIconBtn = document.getElementById('filter-icon-btn');
            filterDropdownContent = document.getElementById('filter-dropdown-content');
            categoryFilterSelect = document.getElementById('category-filter-select');
            completionFilterContainer = document.getElementById('completion-filter-container');
            dateDisplayBtn = document.getElementById('date-display-btn');
            dateDisplayText = document.getElementById('date-display-text');
            hiddenDateInput = document.getElementById('hidden-date-input');
            activeFiltersContainer = document.getElementById('active-filters-container');
            dateNavContainer = document.getElementById('date-nav-container');
            smartViewSwitcherMain = document.getElementById('smart-view-switcher-main');
            smartViewSwitcherText = document.getElementById('smart-view-switcher-text');
            smartViewSwitcherDropdownBtn = document.getElementById('smart-view-switcher-dropdown-btn');
            dateViewDropdown = document.getElementById('date-view-dropdown');
            rescheduleFlyout = document.getElementById('reschedule-flyout');
            hiddenReschedulePicker = document.getElementById('hidden-task-reschedule-picker');
            contextualProgressContainer = document.getElementById('contextual-progress-container');
            contextualProgressBar = document.getElementById('contextual-progress-bar');
            contextualProgressText = document.getElementById('contextual-progress-text');
            contextualTopBar = document.getElementById('contextual-top-bar');

            // NEW MODAL ELEMENTS
            addTaskModal = document.getElementById('add-task-modal');
            addTaskForm = document.getElementById('add-task-form');
            modalAddBtn = document.getElementById('modal-add-btn');
            modalCancelBtn = document.getElementById('modal-cancel-btn');
            newTaskTitleInput = document.getElementById('new-task-title');
            newTaskDescriptionInput = document.getElementById('new-task-description');
            newTaskStarredBtn = document.getElementById('new-task-starred-btn');
            subtasksContainer = document.getElementById('subtasks-container');
            newSubtaskInput = document.getElementById('new-subtask-input');
            setDateBtn = document.getElementById('set-date-btn');
            setPriorityBtn = document.getElementById('set-priority-btn');
            setCategoryBtn = document.getElementById('set-category-btn');
            setTimeBtn = document.getElementById('set-time-btn');
            setDurationBtn = document.getElementById('set-duration-btn');
            setRecurrenceBtn = document.getElementById('set-recurrence-btn');
            toggleAdvancedCountdownBtn = document.getElementById('toggle-advanced-countdown-btn');
            hiddenDatePickerInput = document.getElementById('hidden-date-picker-input');
            priorityPopover = document.getElementById('priority-popover');
            categoryPopover = document.getElementById('category-popover');
            popoverCategoryInput = document.getElementById('popover-category-input');
            popoverCategoryList = document.getElementById('popover-category-list');
            timePopover = document.getElementById('time-popover');
            popoverTimeInput = document.getElementById('popover-time-input');
            durationPopover = document.getElementById('duration-popover');
            popoverDurationValue = document.getElementById('popover-duration-value');
            popoverDurationUnit = document.getElementById('popover-duration-unit');
            recurrencePopover = document.getElementById('recurrence-popover');
            advancedCountdownPopover = document.getElementById('advanced-countdown-popover');
            newTaskShowCountdownTimerCheckbox = document.getElementById('new-task-show-countdown-timer');
            newTaskCountdownThresholdValueInput = document.getElementById('new-task-countdown-threshold-value');
            newTaskCountdownThresholdUnitSelect = document.getElementById('new-task-countdown-threshold-unit');
            newTaskAutoStartTimerCheckbox = document.getElementById('new-task-auto-start-timer');
            
            /* START: M1, M2, M3, M4 Query DOM */
            newTaskMonthlyKeyResultsWrapper = document.getElementById('new-task-monthly-key-results-wrapper');
            keyResultsContainer = document.getElementById('key-results-container');
            addKeyResultBtn = document.getElementById('add-key-result-btn');
            newTaskQuarterlyMetricsWrapper = document.getElementById('new-task-quarterly-metrics-wrapper');
            newTaskQuarterlyMetrics = document.getElementById('new-task-quarterly-metrics');
            newTaskQuarterlyStatusWrapper = document.getElementById('new-task-quarterly-status-wrapper');
            newTaskQuarterlyStatus = document.getElementById('new-task-quarterly-status');
            newTaskYearlyDomainWrapper = document.getElementById('new-task-yearly-domain-wrapper');
            newTaskYearlyDomain = document.getElementById('new-task-yearly-domain');
            newTaskYearlyIconWrapper = document.getElementById('new-task-yearly-icon-wrapper');
            newTaskYearlyIcon = document.getElementById('new-task-yearly-icon');
            newTaskYearlyWhyWrapper = document.getElementById('new-task-yearly-why-wrapper');
            newTaskYearlyWhy = document.getElementById('new-task-yearly-why');
            newTaskWeeklyReviewWrapper = document.getElementById('new-task-weekly-review-wrapper');
            newTaskWeeklyReviewCheckbox = document.getElementById('new-task-weekly-review');
            /* END: M1, M2, M3, M4 Query DOM */
        }
    
        // --- NEW MODAL UI LOGIC (INTEGRATED) ---
        function resetModalState() {
            currentModalState = { 
                title: '', description: '', starred: false, subtasks: [], 
                date: new Date(viewDates[currentDateViewMode]),
                priority: 'medium', category: DEFAULT_CATEGORY, time: '', duration: null, 
                recurrence: 'none', viewMode: currentDateViewMode, 
                showCountdownWithDurationTimer: false,
                countdownThreshold: { value: 4, unit: 'hours' }, 
                autoStartTimer: false
            };
        }

        function openModal(taskId = null) {
            resetModalState();
            editingTaskId = taskId;

            /* START: M4 Reset State */
            newTaskWeeklyReviewCheckbox.checked = false;
            /* END: M4 Reset State */
            
            /* START: M1 Reset State */
            currentKeyResultsInModal = [];
            /* END: M1 Reset State */
            
            if (editingTaskId) {
                const task = findTask(editingTaskId);
                if (!task) return;
                currentModalState = { ...currentModalState, ...JSON.parse(JSON.stringify(task)), date: new Date(task.date) };
                
                /* START: M1 Populate State */
                currentKeyResultsInModal = JSON.parse(JSON.stringify(task.keyResults || []));
                /* END: M1 Populate State */
                
                /* START: M2 & M3 Populate State */
                newTaskQuarterlyMetrics.value = task.successMetrics || '';
                newTaskQuarterlyStatus.value = task.status || 'not_started';
                newTaskYearlyDomain.value = task.domain || 'work';
                newTaskYearlyIcon.value = task.icon || 'ğŸ¯';
                newTaskYearlyWhy.value = task.motivation || '';
                /* END: M2 & M3 Populate State */

                /* START: M4 Populate State */
                newTaskWeeklyReviewCheckbox.checked = task.needsReview;
                /* END: M4 Populate State */

                modalAddBtn.textContent = "Ø­ÙØ¸";
            } else {
                modalAddBtn.textContent = "Ø¥Ø¶Ø§ÙØ©";
            }
            updateModalUIFromState();
            /* START: M1 Render Modal UI */
            renderKeyResultsInModal();
            /* END: M1 Render Modal UI */
            modalAddBtn.disabled = !currentModalState.title.trim();
            addTaskModal.classList.remove('hidden');
            setTimeout(() => newTaskTitleInput.focus(), 50);
        }

        function closeModal() {
            closeActivePopover();
            editingTaskId = null;
            addTaskModal.classList.add('hidden');
        }

        function updateModalUIFromState() {
            newTaskTitleInput.value = currentModalState.title;
            newTaskDescriptionInput.value = currentModalState.description;
            updateStarredUI(currentModalState.starred);
            updateDateUI(currentModalState.date);
            updatePriorityUI(currentModalState.priority);
            updateCategoryUI(currentModalState.category);
            updateTimeUI(currentModalState.time);
            updateDurationUI(currentModalState.duration);
            updateRecurrenceUI(currentModalState.recurrence);
            updateAdvancedCountdownUI();
            renderSubtasksInModal();

            // Hide all new wrappers by default
            newTaskMonthlyKeyResultsWrapper.classList.add('hidden');
            newTaskQuarterlyMetricsWrapper.classList.add('hidden');
            newTaskQuarterlyStatusWrapper.classList.add('hidden');
            newTaskYearlyDomainWrapper.classList.add('hidden');
            newTaskYearlyIconWrapper.classList.add('hidden');
            newTaskYearlyWhyWrapper.classList.add('hidden');
            newTaskWeeklyReviewWrapper.classList.add('hidden');
            
            // Context-aware button visibility
            const viewMode = currentModalState.viewMode;
            setTimeBtn.style.display = viewMode === 'days' ? 'inline-flex' : 'none';
            setPriorityBtn.style.display = (viewMode === 'days' || viewMode === 'weeks') ? 'inline-flex' : 'none';
            setRecurrenceBtn.style.display = (viewMode === 'days' || viewMode === 'weeks') ? 'inline-flex' : 'none';

            let durationVisible = ['days', 'weeks', 'months'].includes(viewMode);
            setDurationBtn.style.display = durationVisible ? 'inline-flex' : 'none';
            if (toggleAdvancedCountdownBtn.parentElement.querySelector('#set-time-btn').style.display === 'none') {
                setDurationBtn.style.borderLeft = '1px solid #4b5563';
                setDurationBtn.style.borderRadius = '0.375rem';
            } else {
                 setDurationBtn.style.borderLeft = 'none';
                 setDurationBtn.style.borderTopLeftRadius = '0.375rem';
                 setDurationBtn.style.borderBottomLeftRadius = '0.375rem';
            }

            /* START: M1, M2, M3, M4 Contextual UI */
            switch (viewMode) {
                case 'days':
                    break;
                case 'weeks':
                    newTaskWeeklyReviewWrapper.classList.remove('hidden');
                    break;
                case 'months':
                    newTaskMonthlyKeyResultsWrapper.classList.remove('hidden');
                    break;
                case 'quarters':
                    newTaskQuarterlyMetricsWrapper.classList.remove('hidden');
                    newTaskQuarterlyStatusWrapper.classList.remove('hidden');
                    break;
                case 'years':
                    newTaskYearlyDomainWrapper.classList.remove('hidden');
                    newTaskYearlyIconWrapper.classList.remove('hidden');
                    newTaskYearlyWhyWrapper.classList.remove('hidden');
                    break;
            }
            /* END: M1, M2, M3, M4 Contextual UI */
        }

        function updateStarredUI(isStarred) {
            currentModalState.starred = isStarred;
            newTaskStarredBtn.classList.toggle('starred', isStarred);
            newTaskStarredBtn.querySelector('i').className = isStarred ? 'fas fa-star text-lg' : 'far fa-star text-lg';
        }
        function updateDateUI(dateObj) {
            currentModalState.date = dateObj ? new Date(dateObj) : new Date();
            const btnText = setDateBtn.querySelector('.btn-text');
            const today = new Date(); today.setHours(0,0,0,0);
            const tomorrow = new Date(); tomorrow.setDate(today.getDate() + 1);
            if (isSameDay(currentModalState.date, today)) {
                btnText.textContent = "Ø§Ù„ÙŠÙˆÙ…";
            } else if (isSameDay(currentModalState.date, tomorrow)) {
                btnText.textContent = "ØºØ¯Ù‹Ø§";
            } else {
                btnText.textContent = new Date(currentModalState.date).toLocaleDateString('ar-EG', { day: 'numeric', month: 'short' });
            }
            setDateBtn.classList.add('set');
        }

        function updatePriorityUI(priority) {
            currentModalState.priority = priority;
            const config = PRIORITY_MAP[priority] || PRIORITY_MAP.medium;
            setPriorityBtn.querySelector('.btn-text').textContent = config.text;
            setPriorityBtn.querySelector('i').className = config.icon;
            setPriorityBtn.className = 'attribute-btn set';
            setPriorityBtn.classList.add(config.class);
        }
        function updateCategoryUI(category) {
            currentModalState.category = category || DEFAULT_CATEGORY;
            setCategoryBtn.querySelector('.btn-text').textContent = currentModalState.category;
            setCategoryBtn.classList.add('set');
        }
        function updateTimeUI(time) {
            currentModalState.time = time;
            const btnText = setTimeBtn.querySelector('.btn-text');
            if (time) {
                btnText.textContent = time;
                setTimeBtn.classList.add('set');
            } else {
                btnText.textContent = "Ø§Ù„ÙˆÙ‚Øª";
                setTimeBtn.classList.remove('set');
            }
            popoverTimeInput.value = time;
        }
        function updateDurationUI(duration) {
            currentModalState.duration = duration;
            const btnText = setDurationBtn.querySelector('.btn-text');
            if (duration && duration.value > 0) {
                const unitTextMap = { minutes: 'Ø¯Ù‚ÙŠÙ‚Ø©', hours: 'Ø³Ø§Ø¹Ø©', days: 'ÙŠÙˆÙ… Ø¬Ù‡Ø¯'};
                const unitText = unitTextMap[duration.unit] || duration.unit;
                btnText.textContent = `${duration.value} ${unitText}`;
                setDurationBtn.classList.add('set');
                popoverDurationValue.value = duration.value;
                popoverDurationUnit.value = duration.unit;
                toggleAdvancedCountdownBtn.classList.toggle('hidden', duration.unit !== 'minutes');
            } else {
                btnText.textContent = "Ø§Ù„Ù…Ø¯Ø©";
                setDurationBtn.classList.remove('set');
                popoverDurationValue.value = '';
                toggleAdvancedCountdownBtn.classList.add('hidden');
            }
        }

        function updateRecurrenceUI(recurrence) {
            currentModalState.recurrence = recurrence || 'none';
            const config = RECURRENCE_MAP[currentModalState.recurrence];
            setRecurrenceBtn.querySelector('.btn-text').textContent = config ? config.text : 'Ù…Ø®ØµØµ';
            setRecurrenceBtn.classList.toggle('set', currentModalState.recurrence !== 'none');
        }

        function updateAdvancedCountdownUI() {
            newTaskShowCountdownTimerCheckbox.checked = currentModalState.showCountdownWithDurationTimer;
            newTaskCountdownThresholdValueInput.value = currentModalState.countdownThreshold?.value || '';
            newTaskCountdownThresholdUnitSelect.value = currentModalState.countdownThreshold?.unit || 'hours';
            newTaskAutoStartTimerCheckbox.checked = currentModalState.autoStartTimer;
        }
        
        function renderSubtasksInModal() {
            subtasksContainer.innerHTML = '';
            (currentModalState.subtasks || []).forEach(subtask => {
                const div = document.createElement('div');
                div.className = 'flex items-center gap-2';
                div.innerHTML = `<input type="checkbox" ${subtask.completed ? 'checked' : ''} class="w-4 h-4 rounded-sm bg-gray-600 border-gray-500 flex-shrink-0"><input type="text" value="${subtask.text}" class="flex-grow bg-transparent text-sm text-white focus:outline-none"><button type="button" class="delete-subtask-btn text-gray-500 hover:text-red-400"><i class="fas fa-times fa-sm"></i></button>`;
                div.querySelector('input[type="checkbox"]').addEventListener('change', e => { subtask.completed = e.target.checked; });
                div.querySelector('input[type="text"]').addEventListener('change', e => { subtask.text = e.target.value.trim(); });
                div.querySelector('.delete-subtask-btn').addEventListener('click', () => { currentModalState.subtasks = currentModalState.subtasks.filter(s => s.id !== subtask.id); renderSubtasksInModal(); });
                subtasksContainer.appendChild(div);
            });
        }
        
        function handleAddNewSubtaskFromModal() {
            const text = newSubtaskInput.value.trim();
            if (text) {
                if (!currentModalState.subtasks) currentModalState.subtasks = [];
                currentModalState.subtasks.push({ id: Date.now(), text, completed: false });
                newSubtaskInput.value = '';
                renderSubtasksInModal();
            }
        }

        function togglePopover(popover, button) { const isAlreadyOpen = activePopover && activePopover.popover === popover; if (activePopover) { closeActivePopover(); } if (!isAlreadyOpen) { popover.classList.remove('hidden'); button.classList.add('active-popover'); if (popover === categoryPopover) { renderCategoryPopoverList(''); setTimeout(() => popoverCategoryInput.focus(), 50); } else if(popover === timePopover) { setTimeout(() => popoverTimeInput.focus(), 50); } else if(popover === durationPopover) { setTimeout(() => popoverDurationValue.focus(), 50); } activePopover = { popover, button }; positionPopover(popover, button); } }
        function closeActivePopover() { if (!activePopover) return; activePopover.popover.classList.add('hidden'); activePopover.button.classList.remove('active-popover'); activePopover = null; }
        function positionPopover(popover, button) { const btnRect = button.getBoundingClientRect(); const modalRect = addTaskModal.querySelector('#modal-content-wrapper').getBoundingClientRect(); popover.style.bottom = `${modalRect.bottom - btnRect.top + 8}px`; if (popover.id === 'advanced-countdown-popover') { popover.style.left = 'auto'; popover.style.right = `${modalRect.right - btnRect.right}px`; } else { popover.style.right = 'auto'; popover.style.left = `${btnRect.left - modalRect.left}px`; } }
        function renderCategoryPopoverList(filter) { popoverCategoryList.innerHTML = ''; const all = [...new Set([...savedCategories, ...availableCategories])].sort(); const filtered = filter ? all.filter(c => c.toLowerCase().includes(filter.toLowerCase())) : all; filtered.forEach(cat => { const btn = document.createElement('button'); btn.className = 'popover-option'; btn.textContent = cat; btn.addEventListener('click', () => { updateCategoryUI(cat); closeActivePopover(); }); popoverCategoryList.appendChild(btn); }); }
        
        /* START: M1 Logic Functions */
        function renderKeyResultsInModal() {
            if (!keyResultsContainer) return;
            keyResultsContainer.innerHTML = '';
            
            if (currentKeyResultsInModal.length === 0) {
                currentKeyResultsInModal.push({ id: Date.now(), text: '' });
            }

            currentKeyResultsInModal.forEach(kr => {
                const krEl = document.createElement('div');
                krEl.className = 'flex items-center gap-2';
                
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.value = kr.text;
                textInput.className = 'flex-grow bg-gray-700 rounded p-2 text-white text-sm focus:outline-none focus:ring-1 focus:ring-blue-500';
                textInput.placeholder = 'Ù…Ø«Ø§Ù„: Ø¥Ù†Ø¬Ø§Ø² 50% Ù…Ù† Ø§Ù„Ù…Ø´Ø±ÙˆØ¹';
                textInput.onchange = () => { kr.text = textInput.value.trim(); };

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'text-gray-500 hover:text-red-400';
                deleteBtn.innerHTML = '<i class="fas fa-times-circle"></i>';
                deleteBtn.onclick = () => {
                    currentKeyResultsInModal = currentKeyResultsInModal.filter(item => item.id !== kr.id);
                    renderKeyResultsInModal();
                };
                
                krEl.appendChild(textInput);
                krEl.appendChild(deleteBtn);
                keyResultsContainer.appendChild(krEl);
            });
        }

        function handleAddNewKeyResult() {
            currentKeyResultsInModal.push({ id: Date.now(), text: '' });
            renderKeyResultsInModal();
            const inputs = keyResultsContainer.querySelectorAll('input[type="text"]');
            if(inputs.length > 0) {
                inputs[inputs.length - 1].focus();
            }
        }
        /* END: M1 Logic Functions */

        // --- CORE APPLICATION LOGIC (REFACTORED & INTEGRATED) ---
        function handleModalFormSubmit() {
            currentModalState.title = newTaskTitleInput.value.trim();
            currentModalState.description = newTaskDescriptionInput.value.trim();
            currentModalState.subtasks = currentModalState.subtasks.filter(s => s.text.trim() !== '');

            /* START: M1, M2, M3, M4 Data Collection */
            const monthlyKeyResults = currentModalState.viewMode === 'months' ? currentKeyResultsInModal.filter(kr => kr.text.trim() !== '') : [];
            /* END: M1, M2, M3, M4 Data Collection */
            
            const taskDataForInternalFunctions = {
                ...currentModalState,
                needsReview: currentModalState.viewMode === 'weeks' ? newTaskWeeklyReviewCheckbox.checked : false,
                keyResults: monthlyKeyResults,
                successMetrics: currentModalState.viewMode === 'quarters' ? newTaskQuarterlyMetrics.value.trim() : '',
                status: currentModalState.viewMode === 'quarters' ? newTaskQuarterlyStatus.value : 'not_started',
                domain: currentModalState.viewMode === 'years' ? newTaskYearlyDomain.value : 'work',
                icon: currentModalState.viewMode === 'years' ? newTaskYearlyIcon.value : 'ğŸ¯',
                motivation: currentModalState.viewMode === 'years' ? newTaskYearlyWhy.value.trim() : '',
                recurrence: 'none', // Simplified for the new modal, advanced recurrence can be added back if needed
                customRecurrence: null
            };

            let result;
            if (editingTaskId) {
                result = saveTaskChangesInternal(editingTaskId, taskDataForInternalFunctions);
            } else {
                result = addNewTaskInternal(taskDataForInternalFunctions);
            }

            if (result.success) {
                closeModal();
                renderApp();
                if (result.task && !editingTaskId) {
                    highlightTask(result.task.id);
                }
            } else {
                if (result.message === "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø·Ù„ÙˆØ¨.") {
                    newTaskTitleInput.classList.add('border', 'border-red-500');
                    modalAddBtn.disabled = true;
                } else if (result.message) {
                    alert(`Ø®Ø·Ø£: ${result.message}`);
                }
            }
        }

        function addNewTaskInternal(taskData) {
            const title = taskData.title.trim();
            if (!title) return { success: false, message: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø·Ù„ÙˆØ¨." };
            
            const maxOrder = tasks.length > 0 ? Math.max(0, ...tasks.map(t => t.order || 0)) : 0;
            const category = taskData.category.trim() || DEFAULT_CATEGORY;
            addCategoryIfNotExists(category);

            const newTask = { 
                id: Date.now(), 
                title: title, 
                description: taskData.description.trim(), 
                time: taskData.time || "", 
                date: new Date(taskData.date), 
                priority: taskData.priority, 
                category: category, 
                duration: taskData.duration, 
                recurrence: taskData.recurrence, 
                customRecurrence: taskData.customRecurrence, 
                completed: false, 
                starred: taskData.starred, 
                order: maxOrder + 1, 
                timerActive: false, 
                timerRemainingSeconds: taskData.duration?.unit === 'minutes' ? taskData.duration.value * 60 : null, 
                timerIntervalId: null, 
                timerWasActivePreviously: (taskData.duration?.unit === 'minutes'), 
                showCountdownWithDurationTimer: taskData.duration?.unit === 'minutes' ? taskData.showCountdownWithDurationTimer : false, 
                countdownThresholdOverrideHours: taskData.countdownThreshold?.value || null, 
                viewMode: currentDateViewMode, 
                subtasks: taskData.subtasks || [],
                createdAt: new Date(),
                completedAt: null,
                rescheduleCount: 0,
                completionHistory: [],
                needsReview: taskData.needsReview,
                keyResults: taskData.keyResults,
                successMetrics: taskData.successMetrics,
                status: taskData.status,
                domain: taskData.domain,
                icon: taskData.icon,
                motivation: taskData.motivation,
            }; 
            tasks.push(newTask); 
            saveTasks(); 
            saveCategories(); 
            return { success: true, task: newTask }; 
        }

        function saveTaskChangesInternal(id, taskData) {
            const taskIndex = tasks.findIndex(t => t.id === id); 
            if (taskIndex === -1) return { success: false, message: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‡Ù…Ø©." }; 
            const title = taskData.title.trim(); 
            if (!title) return { success: false, message: "Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø·Ù„ÙˆØ¨." }; 
            
            const task = tasks[taskIndex]; 
            const oldDate = new Date(task.date); 
            
            task.title = title; 
            task.description = taskData.description.trim(); 
            task.time = taskData.time || ""; 
            task.date = new Date(taskData.date);
            task.priority = taskData.priority; 
            const newCategory = taskData.category.trim() || DEFAULT_CATEGORY; 
            addCategoryIfNotExists(newCategory); 
            task.category = newCategory; 
            if (JSON.stringify(task.duration) !== JSON.stringify(taskData.duration)) { 
                if (!task.timerActive) { 
                    task.timerRemainingSeconds = taskData.duration?.unit === 'minutes' ? taskData.duration.value * 60 : null; 
                    task.timerWasActivePreviously = (taskData.duration?.unit === 'minutes'); 
                } else { 
                    task.timerWasActivePreviously = (taskData.duration?.unit === 'minutes'); 
                } 
            } 
            task.duration = taskData.duration; 
            task.starred = taskData.starred; 
            task.recurrence = taskData.recurrence; 
            task.customRecurrence = taskData.customRecurrence; 
            task.showCountdownWithDurationTimer = taskData.duration?.unit === 'minutes' ? taskData.showCountdownWithDurationTimer : false; 
            task.countdownThresholdOverrideHours = taskData.countdownThreshold?.value || null; 
            task.subtasks = taskData.subtasks || []; 
            task.needsReview = taskData.needsReview;
            task.keyResults = taskData.keyResults;
            task.successMetrics = taskData.successMetrics;
            task.status = taskData.status;
            task.domain = taskData.domain;
            task.icon = taskData.icon;
            task.motivation = taskData.motivation;
            
            if (!isSameDay(oldDate, task.date)) {
                task.rescheduleCount = (task.rescheduleCount || 0) + 1;
            }
            saveTasks(); 
            saveCategories(); 
            return { success: true, task: task }; 
        }

        // --- OLDER FUNCTIONS (UNCHANGED or MINOR TWEAKS) ---
        function loadTasks() { 
            let loadedTasks = []; 
            try { 
                const storedTasks = localStorage.getItem(LOCAL_STORAGE_KEY); 
                if (storedTasks) { 
                    loadedTasks = JSON.parse(storedTasks || '[]').map(taskData => { 
                        if (!taskData || typeof taskData.id === 'undefined') return null; 
                        const task = { ...taskData }; 
                        task.date = task.date ? new Date(task.date) : null; 
                        if (!task.date || isNaN(task.date.getTime())) { task.date = new Date(); task.date.setHours(0, 0, 0, 0); } 
                        task.createdAt = taskData.createdAt ? new Date(taskData.createdAt) : new Date(task.date);
                        task.completedAt = taskData.completedAt ? new Date(taskData.completedAt) : null;
                        task.rescheduleCount = taskData.rescheduleCount ?? 0;
                        task.completionHistory = taskData.completionHistory ?? [];
                        task.order = task.order ?? loadedTasks.length + 1; 
                        task.description = task.description ?? ""; 
                        task.recurrence = task.recurrence ?? 'none'; 
                        task.completed = task.completed ?? false; 
                        task.starred = task.starred ?? false; 
                        task.time = task.time ?? ""; 
                        task.priority = task.priority || 'medium'; 
                        task.category = task.category || DEFAULT_CATEGORY; 
                        task.viewMode = taskData.viewMode || 'days'; 
                        task.subtasks = taskData.subtasks || []; 
                        task.customRecurrence = task.customRecurrence || null; 
                        task.duration = taskData.duration || null;
                        task.timerActive = task.timerActive || false;
                        task.timerRemainingSeconds = task.timerRemainingSeconds === undefined ? (task.duration?.unit === 'minutes' ? task.duration.value * 60 : null) : task.timerRemainingSeconds; 
                        task.timerIntervalId = task.timerIntervalId || null; 
                        task.timerWasActivePreviously = task.timerWasActivePreviously || false; 
                        task.showCountdownWithDurationTimer = task.showCountdownWithDurationTimer === undefined ? false : task.showCountdownWithDurationTimer; 
                        task.countdownThresholdOverrideHours = task.countdownThresholdOverrideHours === undefined ? null : (parseInt(task.countdownThresholdOverrideHours, 10) || null); 
                        task.needsReview = taskData.needsReview || false;
                        task.keyResults = taskData.keyResults || [];
                        task.successMetrics = taskData.successMetrics || '';
                        task.status = taskData.status || 'not_started';
                        task.domain = taskData.domain || 'work';
                        task.icon = taskData.icon || 'ğŸ¯';
                        task.motivation = taskData.motivation || '';
                        if (task.category) addCategoryIfNotExists(task.category, true); 
                        return task; 
                    }).filter(task => task !== null); 
                } 
            } catch (error) { console.error("Error loading tasks:", error); } 
            if (loadedTasks.length === 0) { 
                const firstTaskDate = new Date(); firstTaskDate.setHours(18, 0, 0, 0); 
                const weekStartDate = getStartOfWeek(new Date()); 
                loadedTasks = [ 
                    { id: 1, title: "Ø´Ø±Ø§Ø¡ Ø§Ù„Ø¨Ù‚Ø§Ù„Ø© (Ù…Ù‡Ù…Ø© ÙŠÙˆÙ…ÙŠØ©)", description: "Ø¨ÙŠØ¶ØŒ Ø­Ù„ÙŠØ¨ØŒ Ø®Ø¨Ø²\nØ³Ø·Ø± Ø¬Ø¯ÙŠØ¯ Ù‡Ù†Ø§.", time: "18:00", date: firstTaskDate, priority: "high", category: "Ø§Ù„Ù…Ù†Ø²Ù„", duration: { value: 60, unit: 'minutes' }, completed: false, starred: false, order: 1, recurrence: 'none', customRecurrence: null, timerActive: false, timerRemainingSeconds: 3600, timerIntervalId: null, timerWasActivePreviously: true, showCountdownWithDurationTimer: false, countdownThresholdOverrideHours: null, viewMode: 'days', subtasks: [], createdAt: new Date(), completedAt: null, rescheduleCount: 0, completionHistory: [] }, 
                    { id: 2, title: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨Ø±ÙŠØ¯ (Ù…Ù‡Ù…Ø© ÙŠÙˆÙ…ÙŠØ©)", description: "", time: "09:00", date: getNextDayOfWeek(new Date(), 1, 9, 0), priority: "medium", category: "Ø¹Ù…Ù„", duration: null, completed: true, starred: true, order: 2, recurrence: 'none', customRecurrence: null, timerActive: false, timerRemainingSeconds: null, timerIntervalId: null, timerWasActivePreviously: false, showCountdownWithDurationTimer: true, countdownThresholdOverrideHours: 2, viewMode: 'days', subtasks: [], createdAt: new Date(), completedAt: new Date(), rescheduleCount: 0, completionHistory: [] }, 
                    { id: 3, title: "ØªØ®Ø·ÙŠØ· Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù… (Ù…Ù‡Ù…Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©)", date: weekStartDate, viewMode: 'weeks', order: 3, duration: { value: 2, unit: 'hours' }, completed: false, starred: true, recurrence: 'none', subtasks:[], createdAt: new Date(), completedAt: null, rescheduleCount: 0, completionHistory: [] }, 
                    { id: 4, title: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ", date: new Date(new Date().getFullYear(), Math.floor(new Date().getMonth() / 3) * 3, 1), viewMode: 'quarters', duration: null, order: 4, completed: false, starred: true, recurrence: 'none', subtasks:[], createdAt: new Date(), completedAt: null, rescheduleCount: 0, completionHistory: [] }
                ]; 
                loadedTasks.forEach(task => { if(task.category) addCategoryIfNotExists(task.category, true); }); 
            } 
            loadedTasks.sort((a, b) => (a.order || 0) - (b.order || 0)); 
            loadedTasks.forEach((task, index) => { task.order = index + 1; if (task.timerActive) { task.timerActive = false; } task.timerIntervalId = null; }); 
            tasks = loadedTasks; 
            saveCategories(); 
        }

        // --- PASTE ALL OTHER UNCHANGED FUNCTIONS HERE ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Initializing Integrated Task Widget...");
            try {
                queryDOMElements();
                AdvancedStatsHandler.init();
                originalPageTitle = document.title;
                requestNotificationPermission();
                loadWidgetSettings();
                loadTasks();
                loadAvailableCategories();
                loadSavedCategories();
                updateCountdownTimerInterval();
                handleGoToToday();

                const statsHeaderArea = document.querySelector('#tasks-count').parentElement;
                const statsInstructionText = document.getElementById('stats-instruction-text');
                if (statsHeaderArea) {
                    statsHeaderArea.style.cursor = 'pointer';
                    statsHeaderArea.title = 'Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©';
                    statsHeaderArea.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        const dateForStats = viewDates[currentDateViewMode];
                        const positioningElement = tasksCountEl || statsHeaderArea;
                        if (AdvancedStatsHandler.isVisible()) {
                            AdvancedStatsHandler.hide();
                        } else {
                            AdvancedStatsHandler.showForElement(positioningElement, currentDateViewMode, dateForStats);
                        }
                    });
                    if(statsInstructionText){
                        statsInstructionText.textContent = "Ø§Ù†Ù‚Ø± Ù‡Ù†Ø§ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª";
                    }
                }

                // Event Listeners
                addTaskFab?.addEventListener('click', () => openModal());
                addTaskForm?.addEventListener('submit', (e) => { e.preventDefault(); handleModalFormSubmit(); });
                dateDisplayBtn?.addEventListener('click', () => { const today = new Date(); today.setHours(0, 0, 0, 0); if (currentDateViewMode !== 'days' || !isSameDay(viewDates.days, today)) { handleGoToToday(); } else { try { hiddenDateInput.showPicker(); } catch(e) { console.warn("showPicker() not supported."); } } });
                hiddenDateInput?.addEventListener('change', (e) => { const newDate = parseDateInput(e.target.value); if (newDate) { changeViewMode('days'); viewDates.days = newDate; updateSelectionForNewView(); renderApp(); } });
                filterIconBtn?.addEventListener('click', toggleFilterDropdown);
                searchInput?.addEventListener('input', handleSearchInput);
                searchInput?.addEventListener('search', handleSearchClear);
                categoryFilterSelect?.addEventListener('change', handleCategoryFilterChange);
                completionFilterContainer?.querySelectorAll('.completion-filter-btn').forEach(btn => { btn.addEventListener('click', () => handleCompletionFilter(btn.dataset.filter)); });
                activeFiltersContainer?.addEventListener('click', (e) => { const target = e.target.closest('.remove-pill-btn'); if (!target) return; const type = target.dataset.filterType; if (type === 'category') { categoryFilterSelect.value = 'all'; } else if (type === 'completion') { currentCompletionFilter = 'all'; } renderApp(); });
                smartViewSwitcherMain?.addEventListener('click', () => { const nextView = smartViewSwitcherMain.dataset.nextView; if (nextView) { changeViewMode(nextView); } });
                smartViewSwitcherDropdownBtn?.addEventListener('click', (e) => { e.stopPropagation(); dateViewDropdown.classList.toggle('hidden'); });
                dateViewDropdown?.addEventListener('click', (e) => { const target = e.target.closest('button[data-view]'); if (target) { changeViewMode(target.dataset.view); dateViewDropdown.classList.add('hidden'); } });
                document.body.addEventListener('dragover', (event) => { if (taskListContainer && !taskListContainer.contains(event.target) && draggedTaskId !== null && !dateNavContainer.contains(event.target)) { event.preventDefault(); event.dataTransfer.dropEffect = 'none'; } });
                document.body.addEventListener('drop', (event) => { if (taskListContainer && !taskListContainer.contains(event.target) && draggedTaskId !== null && !dateNavContainer.contains(event.target)) { event.preventDefault(); } });
                document.addEventListener('keydown', handleEscapeKey);
                document.addEventListener('touchcancel', handleTouchCancel, { passive: true });
                if (dateNavContainer) { dateNavContainer.addEventListener('touchstart', handleNavDragStart, { passive: true }); dateNavContainer.addEventListener('touchmove', handleNavDragMove, { passive: false }); dateNavContainer.addEventListener('touchend', handleNavDragEnd); dateNavContainer.addEventListener('mousedown', handleNavDragStart); dateNavContainer.addEventListener('mousemove', handleNavDragMove); dateNavContainer.addEventListener('mouseup', handleNavDragEnd); dateNavContainer.addEventListener('mouseleave', handleNavDragEnd); dateNavContainer.addEventListener('dragenter', handleNavDragEnter); dateNavContainer.addEventListener('dragover', handleNavDragOver); dateNavContainer.addEventListener('dragleave', handleNavDragLeave); dateNavContainer.addEventListener('drop', handleNavDrop); }
                
                // NEW MODAL EVENT LISTENERS
                modalCancelBtn.addEventListener('click', closeModal);
                newTaskTitleInput.addEventListener('input', () => { modalAddBtn.disabled = !newTaskTitleInput.value.trim(); });
                newTaskStarredBtn.addEventListener('click', () => updateStarredUI(!currentModalState.starred));
                newSubtaskInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); handleAddNewSubtaskFromModal(); } });
                setDateBtn.addEventListener('click', (e) => { e.stopPropagation(); closeActivePopover(); hiddenDatePickerInput.showPicker ? hiddenDatePickerInput.showPicker() : hiddenDatePickerInput.click(); });
                hiddenDatePickerInput.addEventListener('change', (e) => { if (e.target.value) updateDateUI(parseDateInput(e.target.value)); });
                setPriorityBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(priorityPopover, setPriorityBtn); });
                setCategoryBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(categoryPopover, setCategoryBtn); });
                setTimeBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(timePopover, setTimeBtn); });
                setDurationBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(durationPopover, setDurationBtn); });
                setRecurrenceBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(recurrencePopover, setRecurrenceBtn); });
                toggleAdvancedCountdownBtn.addEventListener('click', e => { e.stopPropagation(); togglePopover(advancedCountdownPopover, toggleAdvancedCountdownBtn); });
                recurrencePopover.querySelectorAll('.popover-option').forEach(btn => btn.addEventListener('click', () => { updateRecurrenceUI(btn.dataset.value); closeActivePopover(); }));
                priorityPopover.querySelectorAll('.popover-option').forEach(btn => btn.addEventListener('click', () => { updatePriorityUI(btn.dataset.value); closeActivePopover(); }));
                popoverCategoryInput.addEventListener('input', (e) => renderCategoryPopoverList(e.target.value));
                popoverCategoryInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); const text = e.target.value.trim(); if (text) { updateCategoryUI(text); closeActivePopover(); } } });
                popoverTimeInput.addEventListener('input', e => updateTimeUI(e.target.value));
                const handleDurationUpdate = () => { const value = parseInt(popoverDurationValue.value, 10); const unit = popoverDurationUnit.value; updateDurationUI(!isNaN(value) && value > 0 ? { value, unit } : null); };
                popoverDurationValue.addEventListener('input', handleDurationUpdate);
                popoverDurationUnit.addEventListener('change', handleDurationUpdate);
                newTaskShowCountdownTimerCheckbox.addEventListener('change', e => { currentModalState.showCountdownWithDurationTimer = e.target.checked; });
                const handleThresholdUpdate = () => { currentModalState.countdownThreshold = { value: parseInt(newTaskCountdownThresholdValueInput.value, 10) || null, unit: newTaskCountdownThresholdUnitSelect.value }; };
                newTaskCountdownThresholdValueInput.addEventListener('input', handleThresholdUpdate);
                newTaskCountdownThresholdUnitSelect.addEventListener('change', handleThresholdUpdate);
                newTaskAutoStartTimerCheckbox.addEventListener('change', e => { currentModalState.autoStartTimer = e.target.checked; });
                addTaskModal.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

                /* START: M1 Event Listener */
                addKeyResultBtn?.addEventListener('click', handleAddNewKeyResult);
                /* END: M1 Event Listener */

                document.addEventListener('click', (event) => {
                    if (activePopover && !activePopover.popover.contains(event.target) && !activePopover.button.contains(event.target)) closeActivePopover();
                    if (filterDropdownContent && !filterDropdownContent.classList.contains('hidden') && !filterIconBtn.closest('#filter-dropdown-container').contains(event.target)) { toggleFilterDropdown(); } 
                    if(dateViewDropdown && !dateViewDropdown.classList.contains('hidden') && !smartViewSwitcherDropdownBtn.closest('#smart-view-switcher').contains(event.target)) { dateViewDropdown.classList.add('hidden'); }
                    document.querySelectorAll('.task-actions-dropdown:not(.hidden)').forEach(d => { if (!d.closest('.actionsDiv').contains(event.target)) { d.classList.add('hidden'); } }); 
                    if(rescheduleFlyout && !rescheduleFlyout.classList.contains('hidden') && !rescheduleFlyout.contains(event.target)) { rescheduleFlyout.classList.add('hidden'); }
                    if (AdvancedStatsHandler.isVisible() && !AdvancedStatsHandler.popoverEl.contains(event.target) && !event.target.closest('#date-nav-container') && !event.target.closest('#tasks-count-wrapper')) { AdvancedStatsHandler.hide(); }
                });

            } catch (error) {
                console.error("FATAL: Widget Initialization failed:", error);
                if (widgetContainer) { widgetContainer.innerHTML = `<div class="p-4 text-center text-red-400">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø©: ${error.message}. Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© Ø£Ùˆ Ù…Ø±Ø§Ø¬Ø¹Ø© ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­ÙƒÙ….</div>`; }
            }
        });

        function showActionSnackbar(message, type = 'info', undoCallback = null) { if (!actionSnackbar || !actionSnackbarMessageEl || !actionSnackbarBtn) return; clearTimeout(undoDeleteTimeoutId); clearTimeout(undoRescheduleTimeoutId); actionSnackbarMessageEl.textContent = message; actionSnackbar.className = ''; actionSnackbar.classList.add(`type-${type}`); if (undoCallback) { actionSnackbarBtn.style.display = 'flex'; actionSnackbarBtn.onclick = undoCallback; const timeoutHandler = () => { if (type === 'delete') { confirmDelete(recentlyDeletedTask?.id); recentlyDeletedTask = null; } else if (type === 'success') { recentlyRescheduledTask = null; } hideActionSnackbar(); }; if (type === 'delete') { undoDeleteTimeoutId = setTimeout(timeoutHandler, UNDO_TIMEOUT); } else { undoRescheduleTimeoutId = setTimeout(timeoutHandler, UNDO_TIMEOUT); } } else { actionSnackbarBtn.style.display = 'none'; actionSnackbarBtn.onclick = null; setTimeout(hideActionSnackbar, INFO_SNACKBAR_TIMEOUT); } actionSnackbar.classList.add('show'); }
        function hideActionSnackbar() { if (actionSnackbar) { actionSnackbar.classList.remove('show'); } }
        const isSameDay = (d1, d2) => { if (!d1 || !d2) return false; const date1 = (d1 instanceof Date) ? d1 : new Date(d1); const date2 = (d2 instanceof Date) ? d2 : new Date(d2); if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return false; return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate(); };
        const formatDateForInput = (dateObj) => { if (!dateObj || isNaN(dateObj.getTime())) return ''; const year = dateObj.getFullYear(); const month = (dateObj.getMonth() + 1).toString().padStart(2, '0'); const day = dateObj.getDate().toString().padStart(2, '0'); return `${year}-${month}-${day}`; };
        function formatTaskDurationForDisplay(totalMinutes) { if (totalMinutes === null || totalMinutes <= 0) return ""; const days = Math.floor(totalMinutes / 1440); const remainingMinutesAfterDays = totalMinutes % 1440; const hours = Math.floor(remainingMinutesAfterDays / 60); const minutes = remainingMinutesAfterDays % 60; let parts = []; if (days > 0) parts.push(`${days} ${days === 1 ? 'ÙŠÙˆÙ…' : 'Ø£ÙŠØ§Ù…'}`); if (hours > 0) parts.push(`${hours} ${hours === 1 || hours === 2 ? 'Ø³' : 'Ø³'}`); if (minutes > 0) parts.push(`${minutes} ${minutes === 1 || minutes === 2 ? 'Ø¯' : 'Ø¯'}`); if (parts.length === 0 && totalMinutes > 0) { return `${totalMinutes} Ø¯`; } return parts.join(' Ùˆ '); }
        function formatSmartDuration(duration) { if (!duration || !duration.value) return ""; switch (duration.unit) { case 'minutes': return formatTaskDurationForDisplay(duration.value); case 'hours': return `${duration.value} ${duration.value === 1 ? 'Ø³Ø§Ø¹Ø©' : (duration.value === 2 ? 'Ø³Ø§Ø¹ØªØ§Ù†' : (duration.value <= 10 ? 'Ø³Ø§Ø¹Ø§Øª' : 'Ø³Ø§Ø¹Ø©'))}`; case 'days': return `${duration.value} ${duration.value === 1 ? 'ÙŠÙˆÙ… Ø¬Ù‡Ø¯' : (duration.value === 2 ? 'ÙŠÙˆÙ…Ø§Ù† Ø¬Ù‡Ø¯' : 'Ø£ÙŠØ§Ù… Ø¬Ù‡Ø¯')}`; default: return ""; } }
        const parseDateInput = (dateString) => { if (!dateString || typeof dateString !== 'string') return null; const parts = dateString.split('-'); if (parts.length !== 3) return null; const year = parseInt(parts[0], 10); const month = parseInt(parts[1], 10) - 1; const day = parseInt(parts[2], 10); if (isNaN(year) || isNaN(month) || isNaN(day)) return null; const date = new Date(year, month, day); if (date.getFullYear() !== year || date.getMonth() !== month || date.getDate() !== day) { return null; } return !isNaN(date.getTime()) ? date : null; };
        function formatFocusTime(totalSeconds) { if (!totalSeconds || totalSeconds <= 0) return "0 Ø¯"; const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); let parts = []; if (hours > 0) parts.push(`${hours} Ø³`); if (minutes > 0) parts.push(`${minutes} Ø¯`); return parts.join(' Ùˆ '); }
        function getWeekNumber(d) { d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7)); var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)); var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7); return [d.getUTCFullYear(), weekNo]; }
        function toggleTaskCompletionInternal(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) return false;
            const task = tasks[taskIndex];
            
            if (task.recurrence && task.recurrence !== 'none') {
                const completionDate = formatDateForInput(viewDates[currentDateViewMode]);
                if (!task.completionHistory) task.completionHistory = [];
                if (!task.completionHistory.includes(completionDate)) {
                    task.completionHistory.push(completionDate);
                }

                const nextOccurrence = getNextOccurrenceDate(task, viewDates[currentDateViewMode]);
                if (nextOccurrence) {
                    task.date = nextOccurrence;
                    task.completed = false;
                } else {
                    task.completed = true;
                    task.completedAt = new Date();
                }
            } else {
                task.completed = !task.completed;
                task.completedAt = task.completed ? new Date() : null;
            }
            
            if (task.completed && task.timerActive) {
                pauseTaskTimer(taskId);
            }
            saveTasks();
            return true;
        }

        function renderApp(searchTerm = searchInput?.value, categoryFilter = categoryFilterSelect?.value, completionFilter = currentCompletionFilter) {
            if (contextualTopBar) contextualTopBar.classList.remove('hidden');
            
            updateHeaderDate(); 
            updateDateDisplay(); 
            renderDateNav(); 
            renderActiveFilters(); 
            
            let tasksToDisplay = getTasks().filter(task => (task.viewMode || 'days') === currentDateViewMode); 
            
            tasksToDisplay = tasksToDisplay.filter(task => {
                const taskDate = task.date ? new Date(task.date) : null;
                if (!taskDate) return false;
                taskDate.setHours(0, 0, 0, 0);
                if (task.recurrence && task.recurrence !== 'none') {
                    for (let d = new Date(selectedDateRange.start); d <= selectedDateRange.end; d.setDate(d.getDate() + 1)) {
                        if (shouldShowRecurringTask(task, d)) return true;
                    }
                    return false;
                } else {
                    return taskDate >= selectedDateRange.start && taskDate <= selectedDateRange.end;
                }
            });

            updateContextualHeaderStats(tasksToDisplay);

            if (categoryFilter && categoryFilter !== "all") {
                tasksToDisplay = tasksToDisplay.filter(t => t.category === categoryFilter);
            }
            if (completionFilter === 'pending') {
                tasksToDisplay = tasksToDisplay.filter(t => !t.completed);
            } else if (completionFilter === 'completed') {
                tasksToDisplay = tasksToDisplay.filter(t => t.completed);
            }
            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                tasksToDisplay = tasksToDisplay.filter(t => t.title.toLowerCase().includes(lowerSearchTerm) || (t.description && t.description.toLowerCase().includes(lowerSearchTerm)));
            }
            const priorityOrder = { 'high': 1, 'medium': 2, 'low': 3 };
            tasksToDisplay.sort((a, b) => {
                if (completionFilter === 'all') { if (a.completed !== b.completed) return a.completed ? 1 : -1; }
                const dateA = a.date; const dateB = b.date; const timeA = a.time || '00:00'; const timeB = b.time || '00:00';
                const fullDateA = new Date(dateA); const [hA, mA] = timeA.split(':'); fullDateA.setHours(parseInt(hA), parseInt(mA));
                const fullDateB = new Date(dateB); const [hB, mB] = timeB.split(':'); fullDateB.setHours(parseInt(hB), parseInt(mB));
                if (fullDateA - fullDateB !== 0) return fullDateA - fullDateB;
                if (a.starred !== b.starred) return a.starred ? -1 : 1;
                if (a.priority !== b.priority) return (priorityOrder[a.priority] || 99) - (priorityOrder[b.priority] || 99);
                return (a.order || 0) - (b.order || 0);
            });

            populateCategoryFilterSelect();
            renderTasksInternal(tasksToDisplay, searchTerm);
            updateAllCountdowns();
            updateCompletionFilterButtonStates();
        }
        
        function renderDaysView() { 
            const fragment = document.createDocumentFragment(); 
            const currentDate = viewDates.days; 
            const weekStart = getStartOfWeek(currentDate); 
            const today = new Date(); today.setHours(0, 0, 0, 0); 
            for (let i = 0; i < 7; i++) { 
                const day = new Date(weekStart); day.setDate(weekStart.getDate() + i); 
                const item = document.createElement('div'); 
                item.className = 'nav-item'; 
                item.classList.toggle('selected', isSameDay(day, viewDates.days)); 
                item.classList.toggle('today', isSameDay(day, today)); 
                item.classList.toggle('different-month', day.getMonth() !== currentDate.getMonth()); 
                item.dataset.date = formatDateForInput(day); 
                item.title = `${WEEK_DAYS_ARABIC[day.getDay()]} ${day.getDate()}`; 
                item.innerHTML = `<span class="nav-item-label">${WEEK_DAYS_SHORT_ARABIC[day.getDay()]}</span><span class="nav-item-circle">${day.getDate()}</span>`;
                item.onclick = (e) => handleItemClick(e, item, 'days', day);
                fragment.appendChild(item);
            } 
            dateNavContainer.appendChild(fragment); 
        }
        function renderWeeksView() {
            let currentDate = viewDates.weeks; let year = currentDate.getFullYear(); let month = currentDate.getMonth(); const weeksInView = getWeeksForMonth(year, month);
            const [, currentSelectedGlobalWeek] = getWeekNumber(currentDate); const currentSelectedYear = getStartOfWeek(currentDate).getFullYear();
            let currentWeekIndex = weeksInView.findIndex(w => w.weekNum === currentSelectedGlobalWeek && w.start.getFullYear() === currentSelectedYear);
            if (currentWeekIndex === -1) { currentWeekIndex = 0; } dateNavContainer.innerHTML = ''; const weeksContainer = document.createElement('div'); weeksContainer.className = 'flex items-center w-full';
            weeksInView.forEach((week, index) => {
                const weekItem = document.createElement('div'); weekItem.className = 'week-nav-item';
                weekItem.classList.toggle('selected', index === currentWeekIndex);
                if (week.start.getMonth() !== week.end.getMonth()) { weekItem.classList.add('spanning-week'); if (week.start.getMonth() !== month) { weekItem.classList.add('span-starts-prev'); } if (week.end.getMonth() !== month) { weekItem.classList.add('span-ends-next'); } }
                const startDay = week.start.getDate(); const endDay = week.end.getDate(); const endMonthShort = ARABIC_MONTHS[week.end.getMonth()].substring(0, 3);
                weekItem.dataset.date = formatDateForInput(week.start);
                weekItem.innerHTML = `<div class="week-content-wrapper"><span class="week-number">Ø£${week.weekNum}</span><span class="week-range"><span class="separator" aria-hidden="true">|</span>${startDay} - ${endDay} ${endMonthShort}</span></div>`;
                weekItem.onclick = (e) => handleItemClick(e, weekItem, 'weeks', week.start);
                weeksContainer.appendChild(weekItem);
            });
            dateNavContainer.appendChild(weeksContainer);
            setTimeout(() => { const selectedEl = weeksContainer.querySelector('.selected'); if (selectedEl) { selectedEl.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' }); } }, 100);
        }
        function renderMonthsView() {
            dateNavContainer.classList.add('months-view'); dateNavContainer.classList.toggle('months-view-collapsed', !isMonthViewExpanded);
            const fragment = document.createDocumentFragment(); const currentYear = viewDates.months.getFullYear(); const today = new Date(); const selectedQuarter = Math.floor(viewDates.months.getMonth() / 3);
            for(let i = 0; i < 12; i++) {
                const item = document.createElement('div'); item.className = 'nav-item';
                if (Math.floor(i / 3) !== selectedQuarter) { item.classList.add('out-of-quarter'); }
                const monthDate = new Date(currentYear, i, 1); item.dataset.date = formatDateForInput(monthDate);
                item.classList.toggle('selected', i === viewDates.months.getMonth() && currentYear === viewDates.months.getFullYear());
                item.classList.toggle('today', i === today.getMonth() && currentYear === today.getFullYear());
                item.title = `${ARABIC_MONTHS[i]} ${currentYear}`;
                item.innerHTML = `<span class="nav-item-label">${ARABIC_MONTHS[i].substring(0,3)}</span> <span class="nav-item-circle">${i + 1}</span>`;
                item.onclick = (e) => handleItemClick(e, item, 'months', monthDate);
                fragment.appendChild(item);
            }
            dateNavContainer.appendChild(fragment);
            const toggleBtn = document.createElement('button'); toggleBtn.className = 'month-view-toggle';
            toggleBtn.title = isMonthViewExpanded ? 'Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙ‚Ø·' : 'Ø¹Ø±Ø¶ Ø§Ù„Ø³Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©';
            toggleBtn.innerHTML = `<i class="fas fa-chevron-left"></i>`;
            toggleBtn.onclick = (e) => { e.stopPropagation(); isMonthViewExpanded = !isMonthViewExpanded; renderDateNav(); };
            dateNavContainer.appendChild(toggleBtn);
        }
        function renderQuartersView() {
            const fragment = document.createDocumentFragment(); const currentDate = viewDates.quarters; const year = currentDate.getFullYear(); const today = new Date();
            const selectedQuarter = Math.floor(viewDates.quarters.getMonth() / 3); const todayQuarter = Math.floor(today.getMonth() / 3);
            for (let i = 0; i < 4; i++) { 
                const item = document.createElement('div'); item.className = 'nav-item'; 
                const quarterDate = new Date(year, i * 3, 1); item.dataset.date = formatDateForInput(quarterDate);
                item.classList.toggle('selected', i === selectedQuarter && year === viewDates.quarters.getFullYear()); 
                item.classList.toggle('today', i === todayQuarter && year === today.getFullYear()); 
                item.title = `${ARABIC_QUARTERS[i]} ${year}`; 
                item.innerHTML = `<span class="nav-item-label">Ø±Ø¨Ø¹ Ø³Ù†Ø©</span> <span class="nav-item-circle">Q${i + 1}</span>`;
                item.onclick = (e) => handleItemClick(e, item, 'quarters', quarterDate);
                fragment.appendChild(item);
            }
            dateNavContainer.appendChild(fragment);
        }
        function renderYearsView() {
            const fragment = document.createDocumentFragment(); const currentDate = viewDates.years;
            const startYearOfBlock = Math.floor(currentDate.getFullYear() / 5) * 5; const today = new Date();
            for (let i = 0; i < 5; i++) { 
                const year = startYearOfBlock + i; const item = document.createElement('div');
                item.className = 'nav-item'; const yearDate = new Date(year, 0, 1);
                item.dataset.date = formatDateForInput(yearDate);
                item.classList.toggle('selected', year === viewDates.years.getFullYear()); 
                item.classList.toggle('today', year === today.getFullYear()); 
                item.title = year; 
                item.innerHTML = `<span class="nav-item-label">Ø³Ù†Ø©</span> <span class="nav-item-circle">'${year.toString().slice(-2)}</span>`;
                item.onclick = (e) => handleItemClick(e, item, 'years', yearDate);
                fragment.appendChild(item);
            }
            dateNavContainer.appendChild(fragment);
        }
        
        function updateContextualHeaderStats(tasksForView) {
            if (!contextualProgressContainer) return;
            const completedCount = tasksForView.filter(t => t.completed).length;
            const totalCount = tasksForView.length;
            const completionPercentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;
            contextualProgressBar.value = completionPercentage;
            contextualProgressText.textContent = `${completionPercentage}%`;
            contextualProgressContainer.classList.remove('hidden');
        }

        function handleItemClick(event, element, period, date) {
            event.stopPropagation();
            const dateStr = element.dataset.date;
            const statsInstructionText = document.getElementById('stats-instruction-text');
            
            if (lastClickedDateStr === dateStr) {
                if (AdvancedStatsHandler.isVisible()) {
                    AdvancedStatsHandler.hide();
                } else {
                    AdvancedStatsHandler.showForElement(element, period, date);
                }
            } else {
                AdvancedStatsHandler.hide();
                lastClickedDateStr = dateStr;
                const selectionHandlers = {
                    days: handleDayClick,
                    weeks: handleWeekClick,
                    months: (d) => handleMonthClick(d.getFullYear(), d.getMonth()),
                    quarters: (d) => handleQuarterClick(d.getFullYear(), Math.floor(d.getMonth() / 3)),
                    years: (d) => handleYearClick(d.getFullYear())
                };
                selectionHandlers[period](date);
            }
            
            if(statsInstructionText){
                statsInstructionText.textContent = "Ø§Ù†Ù‚Ø± Ù‡Ù†Ø§ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª";
            }
        }
        function handleDayClick(day) { viewDates.days = new Date(day); updateSelectionForNewView(); renderApp(); }
    function handleWeekClick(weekStartDate) { viewDates.weeks = new Date(weekStartDate); updateSelectionForNewView(); renderApp(); }
    function handleMonthClick(year, month) { viewDates.months = new Date(year, month, 1); updateSelectionForNewView(); renderApp(); }
    function handleQuarterClick(year, quarterIndex) { const startMonth = quarterIndex * 3; viewDates.quarters = new Date(year, startMonth, 1); viewDates.months = new Date(viewDates.quarters); updateSelectionForNewView(); renderApp(); }
    function handleYearClick(year) { viewDates.years = new Date(year, 0, 1); updateSelectionForNewView(); renderApp(); }
    function updateSelectionForNewView() { const selectedDate = viewDates[currentDateViewMode]; const start = new Date(selectedDate); start.setHours(0, 0, 0, 0); const end = new Date(selectedDate); end.setHours(23, 59, 59, 999); switch (currentDateViewMode) { case 'days': break; case 'weeks': const dayOfWeek = start.getDay(); const diff = start.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); start.setDate(diff); end.setDate(start.getDate() + 6); break; case 'months': start.setDate(1); end.setMonth(start.getMonth() + 1, 0); break; case 'quarters': const quarter = Math.floor(start.getMonth() / 3); const startMonth = quarter * 3; start.setMonth(startMonth, 1); end.setMonth(startMonth + 3, 0); break; case 'years': start.setMonth(0, 1); end.setFullYear(start.getFullYear(), 11, 31); break; } selectedDateRange = { start, end }; }
    function updateDateDisplay() { if (!dateDisplayText) return; const selectedDate = viewDates[currentDateViewMode]; const today = new Date(); today.setHours(0, 0, 0, 0); let dateString = ""; const year = selectedDate.getFullYear(); switch(currentDateViewMode) { case 'days': const isToday = isSameDay(selectedDate, today); if (isToday) { dateString = "Ø§Ù„ÙŠÙˆÙ…"; } else { dateString = selectedDate.toLocaleDateString('ar-EG', { year: 'numeric', month: 'long', day: 'numeric' }); } break; case 'weeks': const [, weekNum] = getWeekNumber(selectedDate); dateString = `Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${weekNum}ØŒ ${year}`; break; case 'months': dateString = `${ARABIC_MONTHS[selectedDate.getMonth()]}ØŒ ${year}`; break; case 'quarters': const quarter = Math.floor(selectedDate.getMonth() / 3); dateString = `${ARABIC_QUARTERS[quarter]}ØŒ ${year}`; break; case 'years': dateString = year.toString(); break; } dateDisplayText.textContent = dateString; hiddenDateInput.value = formatDateForInput(selectedDate); }
    function updateSmartViewSwitcher() { const currentIndex = VIEW_HIERARCHY.levels.indexOf(currentDateViewMode); const nextIndex = (currentIndex + 1) % VIEW_HIERARCHY.levels.length; const nextView = VIEW_HIERARCHY.levels[nextIndex]; smartViewSwitcherText.textContent = VIEW_HIERARCHY.nextLabels[currentDateViewMode]; smartViewSwitcherMain.dataset.nextView = nextView; smartViewSwitcherMain.disabled = false; smartViewSwitcherMain.title = `Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ ${VIEW_HIERARCHY.labels[nextView]}`; const iconEl = smartViewSwitcherMain.querySelector('i'); if(iconEl) { iconEl.className = `fas ${VIEW_HIERARCHY.nextIcons[currentDateViewMode]}`; } }
    function renderActiveFilters() { if (!activeFiltersContainer) return; activeFiltersContainer.innerHTML = ''; const fragment = document.createDocumentFragment(); const createPill = (text, type, value) => { const pill = document.createElement('div'); pill.className = 'filter-pill'; pill.innerHTML = `<span>${text}</span><button class="remove-pill-btn" data-filter-type="${type}" data-filter-value="${value}" title="Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙÙ„ØªØ±">&times;</button>`; return pill; }; if (categoryFilterSelect?.value && categoryFilterSelect.value !== 'all') { fragment.appendChild(createPill(`Ø§Ù„ÙØ¦Ø©: ${categoryFilterSelect.value}`, 'category', '')); } if (currentCompletionFilter && currentCompletionFilter !== 'all') { const statusText = currentCompletionFilter === 'pending' ? 'Ø§Ù„Ø­Ø§Ù„Ø©: Ø¬Ø§Ø±ÙŠØ©' : 'Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ÙƒØªÙ…Ù„Ø©'; fragment.appendChild(createPill(statusText, 'completion', '')); } activeFiltersContainer.appendChild(fragment); }
    function handleGoToToday() { changeViewMode('days'); const today = new Date(); today.setHours(0,0,0,0); Object.keys(viewDates).forEach(key => viewDates[key] = new Date(today)); if (searchInput) searchInput.value = ''; if (categoryFilterSelect) categoryFilterSelect.value = 'all'; currentCompletionFilter = 'all'; isMonthViewExpanded = false; updateSelectionForNewView(); renderApp(); }
    function changeViewMode(view) { if (currentDateViewMode === 'months' && view !== 'months') isMonthViewExpanded = false; currentDateViewMode = view; lastClickedDateStr = null; AdvancedStatsHandler.hide(); updateSelectionForNewView(); renderApp(); }
    function renderTasksInternal(tasksToDisplay, searchTerm = '') { if (!taskListContainer || !tasksCountEl || !noTasksMessage) return; taskListContainer.innerHTML = ''; tasksCountEl.textContent = `${VIEW_MODE_CONFIG[currentDateViewMode].modalTitle.split(' ')[0]} (${tasksToDisplay.length})`; const fragment = document.createDocumentFragment(); const pendingDeleteTask = getPendingDeleteTask(); if (tasksToDisplay.length === 0) { noTasksMessage.classList.remove('hidden'); if (searchTerm) { noTasksMessage.textContent = `Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø­Ø«Ùƒ "${searchTerm}"`; } else { noTasksMessage.textContent = VIEW_MODE_CONFIG[currentDateViewMode].noTasksMessage; } } else { noTasksMessage.classList.add('hidden'); tasksToDisplay.forEach(taskView => { const taskElement = createTaskElement(taskView); if (taskElement) { if (pendingDeleteTask && pendingDeleteTask.id === taskView.id) { taskElement.style.display = 'none'; } fragment.appendChild(taskElement); } }); } taskListContainer.appendChild(fragment); updateAllCountdowns(); }
    function switchToViewDescription(taskId, container, descriptionText) { if (!container) return; container.innerHTML = ''; const hasDescription = descriptionText && descriptionText.trim().length > 0; const textDisplay = document.createElement('p'); textDisplay.className = 'description-text-display whitespace-pre-wrap'; textDisplay.textContent = hasDescription ? descriptionText : "Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ. Ø§Ø¶ØºØ· Ù„Ù„ØªØ¹Ø¯ÙŠÙ„."; textDisplay.style.color = hasDescription ? '' : '#9ca3af'; const editBtn = document.createElement('button'); editBtn.type = 'button'; editBtn.className = 'edit-description-btn action-btn'; editBtn.innerHTML = '<i class="fas fa-pencil-alt"></i>'; editBtn.title = 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙˆØµÙ'; const wrapper = document.createElement('div'); wrapper.className = 'relative group'; wrapper.appendChild(textDisplay); wrapper.appendChild(editBtn); editBtn.style.opacity = '0'; editBtn.style.transition = 'opacity 0.2s'; wrapper.onmouseover = () => editBtn.style.opacity = '1'; wrapper.onmouseout = () => editBtn.style.opacity = '0'; wrapper.onclick = (e) => { e.stopPropagation(); switchToEditDescription(taskId, container, descriptionText); }; container.appendChild(wrapper); }
    function switchToEditDescription(taskId, container, currentDescription) { if (!container) return; container.innerHTML = ''; const textarea = document.createElement('textarea'); textarea.value = currentDescription; textarea.rows = 3; textarea.className = 'w-full bg-gray-700 rounded p-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y'; textarea.addEventListener('keydown', (e) => { if (e.key === 'Escape') { e.stopPropagation(); switchToViewDescription(taskId, container, currentDescription); } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.stopPropagation(); const task = findTask(taskId); if (task) { task.description = textarea.value.trim(); saveTasks(); switchToViewDescription(taskId, container, task.description); const taskItem = container.closest('.task-item'); if(taskItem) { taskItem.classList.add('bg-blue-900/30'); setTimeout(() => taskItem.classList.remove('bg-blue-900/30'), 500); } } } }); const controlsDiv = document.createElement('div'); controlsDiv.className = 'description-edit-controls'; const saveBtn = document.createElement('button'); saveBtn.type = 'button'; saveBtn.textContent = 'Ø­ÙØ¸'; saveBtn.className = 'save-desc-btn'; saveBtn.addEventListener('click', (e) => { e.stopPropagation(); const task = findTask(taskId); if (task) { task.description = textarea.value.trim(); saveTasks(); switchToViewDescription(taskId, container, task.description); } }); const cancelBtn = document.createElement('button'); cancelBtn.type = 'button'; cancelBtn.textContent = 'Ø¥Ù„ØºØ§Ø¡'; cancelBtn.className = 'cancel-desc-btn'; cancelBtn.addEventListener('click', (e) => { e.stopPropagation(); switchToViewDescription(taskId, container, currentDescription); }); controlsDiv.appendChild(cancelBtn); controlsDiv.appendChild(saveBtn); container.appendChild(textarea); container.appendChild(controlsDiv); container.classList.remove('hidden'); textarea.focus(); textarea.selectionStart = textarea.selectionEnd = textarea.value.length; }

    function createTaskElement(taskViewData) {
        const originalTask = findTask(taskViewData.id);
        if (!originalTask) return null;

        const displayCompleted = taskViewData.completed;
        const hasDetails = (originalTask.description && originalTask.description.trim() !== '') ||
            (originalTask.subtasks && originalTask.subtasks.length > 0) ||
            (originalTask.keyResults && originalTask.keyResults.length > 0) ||
            (originalTask.rescheduleCount > 0) ||
            (originalTask.completionHistory && originalTask.completionHistory.length > 0);

        const taskEl = document.createElement('div');
        taskEl.className = `task-item flex flex-col rounded p-3 relative ${displayCompleted ? 'bg-gray-700/50 text-gray-500' : 'bg-gray-800 hover:bg-gray-700/70'} transition-all duration-300`;
        taskEl.setAttribute('draggable', !displayCompleted);
        taskEl.dataset.taskId = originalTask.id;
        taskEl.dataset.instanceKey = taskViewData.instanceKey || `task_${originalTask.id}`;
        taskEl.style.cursor = 'default';
        taskEl.setAttribute('role', 'listitem');
        taskEl.setAttribute('aria-label', `${originalTask.title}${originalTask.recurrence !== 'none' ? ' (Ù…Ù‡Ù…Ø© Ù…ØªÙƒØ±Ø±Ø©)' : ''}${displayCompleted ? ' (Ù…ÙƒØªÙ…Ù„Ø©)' : ''}`);
        taskEl.dataset.subtasksVisible = "false";

        const mainContentRow = document.createElement('div');
        mainContentRow.className = 'flex items-start w-full';

        const checkboxDiv = document.createElement('div');
        checkboxDiv.className = "ml-3 flex-shrink-0 pt-1";
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = displayCompleted;
        const checkboxId = `task-check-${taskViewData.instanceKey || originalTask.id}`;
        checkbox.id = checkboxId;
        checkbox.className = "w-5 h-5 rounded-sm bg-gray-700 border-gray-500 cursor-pointer focus:ring-blue-500 focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800";
        checkbox.setAttribute('aria-labelledby', `task-title-label-${taskViewData.instanceKey || originalTask.id}`);
        checkbox.addEventListener('change', () => handleToggleCompletion(originalTask.id, taskViewData.isRecurringInstance));
        checkboxDiv.appendChild(checkbox);
        mainContentRow.appendChild(checkboxDiv);

        const detailsDiv = document.createElement('div');
        detailsDiv.className = "flex-1 min-w-0 mr-2";

        const titleAndActionsWrapper = document.createElement('div');
        titleAndActionsWrapper.className = 'flex justify-between items-start';

        const titleContentDiv = document.createElement('div');
        titleContentDiv.className = "flex-1 task-main-content";

        const titleDiv = document.createElement('div');
        titleDiv.className = "flex items-center";

        if (hasDetails && !displayCompleted) {
            const expandIcon = document.createElement('span');
            expandIcon.className = "expand-indicator mr-2";
            expandIcon.innerHTML = `<i class="fas fa-chevron-left fa-xs"></i>`;
            titleDiv.appendChild(expandIcon);
        }

         if (originalTask.icon && !displayCompleted) { const iconSpan = document.createElement('span'); iconSpan.className = 'mr-2 text-lg'; iconSpan.textContent = originalTask.icon; titleDiv.appendChild(iconSpan); }
        if (originalTask.needsReview && !displayCompleted) { const reviewIcon = document.createElement('span'); reviewIcon.className = 'mr-2 text-green-400'; reviewIcon.title = 'ÙŠØªØ·Ù„Ø¨ Ù…Ø±Ø§Ø¬Ø¹Ø© ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹'; reviewIcon.innerHTML = '<i class="fas fa-clipboard-check"></i>'; titleDiv.appendChild(reviewIcon); }
        if (originalTask.subtasks && originalTask.subtasks.length > 0 && !displayCompleted) { const completedCount = originalTask.subtasks.filter(s => s.completed).length; const totalCount = originalTask.subtasks.length; const indicator = document.createElement('span'); indicator.className = 'subtask-indicator'; if(completedCount === totalCount) indicator.classList.add('all-done'); indicator.title = 'ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ù‡Ø§Ù… ÙØ±Ø¹ÙŠØ©'; indicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" /></svg><span>${completedCount}/${totalCount}</span>`; titleDiv.appendChild(indicator); }
        if (originalTask.recurrence !== 'none' && !displayCompleted) { const icon = document.createElement('span'); icon.className = 'recurring-icon text-blue-400'; icon.title = 'Ù…Ù‡Ù…Ø© Ù…ØªÙƒØ±Ø±Ø©'; icon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7v-2c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5h2c0-4.97-4.03-9-9-9z"></path></svg>`; titleDiv.appendChild(icon); }


        const titleLabel = document.createElement('label');
        titleLabel.htmlFor = checkboxId;
        titleLabel.id = `task-title-label-${taskViewData.instanceKey || originalTask.id}`;
        titleLabel.className = `font-medium break-words ${displayCompleted ? 'line-through text-gray-500' : 'text-gray-100'}`;
        titleLabel.textContent = originalTask.title;
        titleDiv.appendChild(titleLabel);

        if (originalTask.starred && !displayCompleted) { const starIcon = document.createElement('span'); starIcon.className = "flex-shrink-0 mr-2"; starIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400 fill-yellow-400" aria-label="Ù…Ù‡Ù…Ø© Ù…Ù…ÙŠØ²Ø© Ø¨Ù†Ø¬Ù…Ø©"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>`; titleDiv.appendChild(starIcon); }
        

        titleContentDiv.appendChild(titleDiv);
        titleAndActionsWrapper.appendChild(titleContentDiv);

        const actionsDiv = document.createElement('div');
        actionsDiv.className = "actionsDiv relative flex items-center flex-shrink-0 mr-auto pl-1";
        const dropdownBtn = document.createElement('button');
        dropdownBtn.type = "button";
        dropdownBtn.className = "action-btn text-gray-500 hover:text-blue-400";
        dropdownBtn.title = "Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª";
        dropdownBtn.innerHTML = '<i class="fas fa-ellipsis-v"></i>';
        actionsDiv.appendChild(dropdownBtn);
        const dropdownContent = document.createElement('div');
        dropdownContent.className = 'task-actions-dropdown hidden';
        
        const editBtn = document.createElement('button');
        editBtn.innerHTML = '<i class="fas fa-pencil-alt"></i><span>ØªØ¹Ø¯ÙŠÙ„</span>'; 
        editBtn.onclick = (e) => { e.stopPropagation(); openModal(originalTask.id); };
        dropdownContent.appendChild(editBtn);

        if (!displayCompleted) {
            const rescheduleBtn = document.createElement('button');
            rescheduleBtn.innerHTML = '<i class="far fa-calendar-alt"></i><span>Ø¥Ø¹Ø§Ø¯Ø© Ø¬Ø¯ÙˆÙ„Ø©</span>';
            rescheduleBtn.onclick = (e) => { e.stopPropagation(); handleOpenRescheduleFlyout(e.currentTarget, originalTask.id); };
            dropdownContent.appendChild(rescheduleBtn);
        }
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-action'; 
        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i><span>Ø­Ø°Ù</span>'; 
        deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteTask(originalTask.id); };
        dropdownContent.appendChild(deleteBtn);
        
        actionsDiv.appendChild(dropdownContent);
        dropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); document.querySelectorAll('.task-actions-dropdown:not(.hidden)').forEach(d => { if (d !== dropdownContent) d.classList.add('hidden'); }); rescheduleFlyout.classList.add('hidden'); dropdownContent.classList.toggle('hidden'); });
        titleAndActionsWrapper.appendChild(actionsDiv);
        detailsDiv.appendChild(titleAndActionsWrapper);

        const combinedMetaLineDiv = document.createElement('div');
        combinedMetaLineDiv.className = "task-meta-line mt-1.5";
        
        if (originalTask.status && !displayCompleted) {
            const statusMap = { not_started: { text: 'Ù„Ù… ÙŠØ¨Ø¯Ø£', color: 'gray-400', icon: 'âšªï¸' }, on_track: { text: 'Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±', color: 'green-400', icon: 'âœ…' }, at_risk: { text: 'Ù…Ø¹Ø±Ø¶ Ù„Ù„Ø®Ø·Ø±', color: 'yellow-400', icon: 'âš ï¸' }, off_track: { text: 'Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…Ø³Ø§Ø±', color: 'red-400', icon: 'âŒ' }, };
            const statusInfo = statusMap[originalTask.status] || statusMap.not_started;
            const statusDiv = document.createElement('div');
            statusDiv.className = `text-${statusInfo.color} font-semibold`;
            statusDiv.title = `Ø§Ù„Ø­Ø§Ù„Ø©: ${statusInfo.text}`;
            statusDiv.innerHTML = `<span>${statusInfo.icon} ${statusInfo.text}</span>`;
            combinedMetaLineDiv.appendChild(statusDiv);
        }
        
         if (originalTask.domain && !displayCompleted) { const domainMap = { work: 'Ø§Ù„Ø¹Ù…Ù„', health: 'Ø§Ù„ØµØ­Ø©', finance: 'Ø§Ù„Ù…Ø§Ù„ÙŠØ©', relationships: 'Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª', personal_growth: 'Ø§Ù„ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠ', hobbies: 'Ø§Ù„Ù‡ÙˆØ§ÙŠØ§Øª' }; const domainDiv = document.createElement('div'); domainDiv.className = 'px-2 py-0.5 text-xs bg-gray-600 rounded-full'; domainDiv.textContent = domainMap[originalTask.domain] || originalTask.domain; combinedMetaLineDiv.appendChild(domainDiv); }
        const hasTimer = originalTask.duration?.unit === 'minutes'; const shouldShowCountdown = (widgetSettings.countdownEnabled && !hasTimer) || (widgetSettings.countdownEnabled && hasTimer && originalTask.showCountdownWithDurationTimer); if (shouldShowCountdown && !displayCompleted && (originalTask.time || originalTask.date)) { const countdownDiv = document.createElement('div'); countdownDiv.className = "task-countdown"; countdownDiv.style.display = 'none'; countdownDiv.setAttribute('aria-live', 'off'); countdownDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 8v4l3 3"></path><path d="M21.58 16.09A10 10 0 1 1 8 2.5a9.96 9.96 0 0 1 11 4.23"></path></svg><span class="countdown-text"></span>`; combinedMetaLineDiv.appendChild(countdownDiv); } if (originalTask.time && !displayCompleted && originalTask.viewMode === 'days') { const timeInfoDiv = document.createElement('div'); timeInfoDiv.className = "task-time-info"; timeInfoDiv.title = `Ø§Ù„ÙˆÙ‚Øª: ${originalTask.time}`; timeInfoDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg><span>${originalTask.time}</span>`; combinedMetaLineDiv.appendChild(timeInfoDiv); } if (originalTask.duration && !displayCompleted) { const durationInfoDiv = document.createElement('div'); durationInfoDiv.className = "task-duration-info"; const formattedDuration = formatSmartDuration(originalTask.duration); durationInfoDiv.title = `Ø§Ù„Ù…Ø¯Ø©: ${formattedDuration}`; durationInfoDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg><span>${formattedDuration}</span>`; combinedMetaLineDiv.appendChild(durationInfoDiv); }
        if (!displayCompleted && (originalTask.viewMode === 'days' || originalTask.viewMode === 'weeks')) { const priorityInfoDiv = document.createElement('div'); priorityInfoDiv.className = `task-priority-info task-priority-${originalTask.priority}`; let priorityText = "Ù…ØªÙˆØ³Ø·Ø©"; if (originalTask.priority === 'high') priorityText = "Ø¹Ø§Ù„ÙŠØ©"; else if (originalTask.priority === 'low') priorityText = "Ù…Ù†Ø®ÙØ¶Ø©"; priorityInfoDiv.title = `Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©: ${priorityText}`; priorityInfoDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></svg><span>${priorityText}</span>`; combinedMetaLineDiv.appendChild(priorityInfoDiv); }
        if (originalTask.category && originalTask.category !== DEFAULT_CATEGORY && !displayCompleted) { const categoryInfoDiv = document.createElement('div'); categoryInfoDiv.className = "task-category-info"; categoryInfoDiv.title = `Ø§Ù„ÙØ¦Ø©: ${originalTask.category}`; categoryInfoDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M2.5 3A1.5 1.5 0 001 4.5v1.382a1.5 1.5 0 00.44 1.06L8 13.523V17.5a1.5 1.5 0 00.946 1.412l2.108.843a.75.75 0 00.946-.411V13.523l6.56-6.579A1.5 1.5 0 0019 5.882V4.5A1.5 1.5 0 0017.5 3h-15zm12.5 0h-10V1.5a.75.75 0 011.5 0V3h7V1.5a.75.75 0 011.5 0V3z" clip-rule="evenodd" /></svg><span>${originalTask.category}</span>`; combinedMetaLineDiv.appendChild(categoryInfoDiv); }
        if (originalTask.duration?.unit === 'minutes' && !displayCompleted) { const timerDisplayDiv = document.createElement('div'); timerDisplayDiv.className = `task-timer-display ${originalTask.timerActive ? 'active' : ''}`; combinedMetaLineDiv.appendChild(timerDisplayDiv); }


        if (combinedMetaLineDiv.children.length > 0) detailsDiv.appendChild(combinedMetaLineDiv);

        mainContentRow.appendChild(detailsDiv);
        taskEl.appendChild(mainContentRow);

        if (hasDetails && !displayCompleted) {
            const taskDetailsContainer = document.createElement('div');
            taskDetailsContainer.className = 'task-details-container';
             if (originalTask.description && originalTask.description.trim() !== '') { const taskDescriptionContentDiv = document.createElement('div'); taskDescriptionContentDiv.className = 'task-description-content'; switchToViewDescription(originalTask.id, taskDescriptionContentDiv, originalTask.description); taskDetailsContainer.appendChild(taskDescriptionContentDiv); }
            if (originalTask.keyResults && originalTask.keyResults.length > 0) { const krContainer = document.createElement('div'); krContainer.className = 'mt-3'; krContainer.innerHTML = '<h5 class="text-xs font-bold text-gray-400 mb-1">Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</h5>'; const krList = document.createElement('ul'); krList.className = 'list-disc list-inside space-y-1 text-sm text-gray-300'; originalTask.keyResults.forEach(kr => { const item = document.createElement('li'); item.textContent = kr.text; krList.appendChild(item); }); krContainer.appendChild(krList); taskDetailsContainer.appendChild(krContainer); }
            if (originalTask.subtasks && originalTask.subtasks.length > 0) { const subtasksControls = document.createElement('div'); subtasksControls.className = 'subtasks-controls'; subtasksControls.innerHTML = '<h5>Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ÙØ±Ø¹ÙŠØ©</h5>'; const toggleBtn = document.createElement('button'); toggleBtn.className = 'toggle-subtasks-btn'; toggleBtn.innerHTML = '<span>Ø¥Ø¸Ù‡Ø§Ø±</span> <i class="fas fa-chevron-down fa-xs ml-1"></i>'; toggleBtn.onclick = (e) => { e.stopPropagation(); const isVisible = taskDetailsContainer.classList.toggle('subtasks-visible'); taskEl.dataset.subtasksVisible = isVisible; toggleBtn.querySelector('span').textContent = isVisible ? 'Ø¥Ø®ÙØ§Ø¡' : 'Ø¥Ø¸Ù‡Ø§Ø±'; }; subtasksControls.appendChild(toggleBtn); taskDetailsContainer.appendChild(subtasksControls); const subtasksListContainer = document.createElement('div'); subtasksListContainer.className = 'subtasks-list-container'; originalTask.subtasks.forEach(subtask => { const subtaskItemEl = document.createElement('div'); subtaskItemEl.className = 'subtask-display-item'; const subtaskCheckboxId = `subtask-check-${subtask.id}`; const subtaskCheckbox = document.createElement('input'); subtaskCheckbox.type = 'checkbox'; subtaskCheckbox.checked = subtask.completed; subtaskCheckbox.id = subtaskCheckboxId; subtaskCheckbox.onchange = (e) => { e.stopPropagation(); handleToggleSubtaskCompletion(originalTask.id, subtask.id); }; const label = document.createElement('label'); label.htmlFor = subtaskCheckboxId; label.textContent = subtask.text; subtaskItemEl.appendChild(subtaskCheckbox); subtaskItemEl.appendChild(label); subtasksListContainer.appendChild(subtaskItemEl); }); taskDetailsContainer.appendChild(subtasksListContainer); }
            const hasStats = (originalTask.rescheduleCount > 0) || (originalTask.completionHistory && originalTask.completionHistory.length > 0);
            if (hasStats) { const statsContainer = document.createElement('div'); statsContainer.className = 'task-stats-container'; statsContainer.innerHTML = '<h5>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø©</h5>'; if (originalTask.rescheduleCount > 0) { const rescheduleStat = document.createElement('div'); rescheduleStat.className = 'stat-item'; rescheduleStat.innerHTML = `<i class="fas fa-history"></i><span>ØªÙ… ØªØ£Ø¬ÙŠÙ„Ù‡Ø§ ${originalTask.rescheduleCount} ${originalTask.rescheduleCount > 2 ? 'Ù…Ø±Ø§Øª' : 'Ù…Ø±Ø©'}</span>`; statsContainer.appendChild(rescheduleStat); } if (originalTask.completionHistory && originalTask.completionHistory.length > 0) { const historyStat = document.createElement('div'); historyStat.className = 'stat-item'; const lastCompletion = new Date(originalTask.completionHistory[originalTask.completionHistory.length - 1]).toLocaleDateString('ar-EG', {day: 'numeric', month: 'short'}); historyStat.innerHTML = `<i class="fas fa-check-double"></i><span>Ø£ÙÙ†Ø¬Ø²Øª ${originalTask.completionHistory.length} Ù…Ø±Ø© (Ø¢Ø®Ø±Ù‡Ø§ ${lastCompletion})</span>`; statsContainer.appendChild(historyStat); } taskDetailsContainer.appendChild(statsContainer); }
            taskEl.appendChild(taskDetailsContainer);
            titleContentDiv.onclick = (e) => { if (e.target.closest('a, button')) return; taskEl.classList.toggle('expanded'); const isNowExpanded = taskEl.classList.contains('expanded'); if (isNowExpanded && taskEl.dataset.subtasksVisible === 'true') { taskDetailsContainer.classList.add('subtasks-visible'); const toggleBtn = taskDetailsContainer.querySelector('.toggle-subtasks-btn'); if(toggleBtn) toggleBtn.querySelector('span').textContent = 'Ø¥Ø®ÙØ§Ø¡'; } };
        }
        const swipeLeftIndicator = document.createElement('div'); swipeLeftIndicator.className = 'swipe-indicator left'; swipeLeftIndicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-400"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`; taskEl.appendChild(swipeLeftIndicator); const swipeRightIndicator = document.createElement('div'); swipeRightIndicator.className = 'swipe-indicator right'; swipeRightIndicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>`; taskEl.appendChild(swipeRightIndicator); if (!displayCompleted) { taskEl.addEventListener('dragstart', handleDragStart); taskEl.addEventListener('dragover', handleDragOver); taskEl.addEventListener('dragleave', handleDragLeave); taskEl.addEventListener('drop', handleDrop); taskEl.addEventListener('dragend', handleDragEnd); taskEl.addEventListener('touchstart', handleTouchStart, { passive: true }); taskEl.addEventListener('touchmove', handleTouchMove, { passive: false }); taskEl.addEventListener('touchend', handleTouchEnd); } else { taskEl.style.touchAction = 'auto'; } if (originalTask.duration?.unit === 'minutes' && !displayCompleted) { updateTaskTimerDisplay(originalTask.id); } if (shouldShowCountdown && !displayCompleted && (originalTask.time || originalTask.date)) { const cdElement = taskEl.querySelector('.task-countdown'); if (cdElement) updateSingleCountdown(originalTask, taskViewData, cdElement); }


        return taskEl;
    }
    
    function highlightTask(taskId) { const taskEl = taskListContainer.querySelector(`.task-item[data-task-id="${taskId}"]`); if (taskEl) { taskEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); taskEl.classList.add('bg-blue-600/30'); setTimeout(() => { taskEl.classList.remove('bg-blue-600/30'); }, 1500); } }
    function handleSearchInput() { renderApp(searchInput.value); }
    
    
            function handleSearchClear() { if (!searchInput.value) renderApp(); }
        function handleCategoryFilterChange() { renderApp(); }
        function handleCompletionFilter(filterValue) { currentCompletionFilter = filterValue; renderApp(); }
        function updateCompletionFilterButtonStates() { if (completionFilterContainer) { completionFilterContainer.querySelectorAll('.completion-filter-btn').forEach(btn => { btn.classList.toggle('active', btn.dataset.filter === currentCompletionFilter); }); } }
        
        function handleToggleCompletion(taskId, isRecurringInstanceView) { const success = toggleTaskCompletionInternal(taskId); if (success) { renderApp(); } }
        function handleDeleteTask(taskId) { if (deleteTaskWithUndoInternal(taskId)) { renderApp(); } }
        
        function handleEscapeKey(event) { if (event.key === 'Escape') { if (!addTaskModal.classList.contains('hidden')) { closeModal(); } else if (filterDropdownContent && !filterDropdownContent.classList.contains('hidden')) { toggleFilterDropdown(); } else if (dateViewDropdown && !dateViewDropdown.classList.contains('hidden')) { dateViewDropdown.classList.add('hidden'); } } }
        
        function handleToggleSubtaskCompletion(taskId, subtaskId) { 
            const task = findTask(taskId); 
            if (task && task.subtasks) { 
                const subtask = task.subtasks.find(s => s.id === subtaskId); 
                if (subtask) { 
                    subtask.completed = !subtask.completed; 
                    saveTasks(); 
                    renderApp(); 
                } 
            } 
        }
        function handleNavDragStart(e) {
            if (e.target.closest('.month-view-toggle')) return; 
            isNavDragging = true;
            navStartX = (e.type.includes('touch') ? e.touches[0].pageX : e.pageX);
            navScrollLeft = dateNavContainer.scrollLeft;
            dateNavContainer.classList.add('dragging');
        }
        function handleNavDragMove(e) {
            if (!isNavDragging) return;
            e.preventDefault();
            const x = (e.type.includes('touch') ? e.touches[0].pageX : e.pageX);
            dateNavContainer.scrollLeft = navScrollLeft - (x - navStartX);
        }
        function handleNavDragEnd(e) {
            if(!isNavDragging) return;
            isNavDragging = false;
            dateNavContainer.classList.remove('dragging');
            const x = (e.type.includes('touch') ? e.changedTouches[0].pageX : e.pageX);
            if (Math.abs(x - navStartX) > 50) {
                navigatePeriod((x - navStartX) > 0 ? 'prev' : 'next');
            }
        }
        function handleOpenRescheduleFlyout(buttonEl, taskId) {
            const rect = buttonEl.getBoundingClientRect();
            const dropdown = buttonEl.closest('.task-actions-dropdown');
            dropdown.classList.add('hidden'); 

            rescheduleFlyout.innerHTML = ''; 
            const options = RESCHEDULE_OPTIONS[currentDateViewMode] || [];
            
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'flyout-btn';
                btn.innerHTML = `<i class="${opt.icon}"></i><span>${opt.label}</span>`;
                btn.onclick = () => rescheduleTask(opt.period, taskId);
                rescheduleFlyout.appendChild(btn);
            });

            rescheduleFlyout.style.top = `${rect.bottom + window.scrollY}px`;
            rescheduleFlyout.style.left = `${rect.left + window.scrollX - rescheduleFlyout.offsetWidth}px`;
            rescheduleFlyout.classList.remove('hidden');
        }
        function rescheduleTask(period, taskId) {
            const task = findTask(taskId);
            if (!task) return;

            if (period === 'pick_date') {
                hiddenReschedulePicker.dataset.taskId = taskId;
                hiddenReschedulePicker.addEventListener('change', handleRescheduleDatePick, { once: true });
                try {
                    hiddenReschedulePicker.showPicker();
                } catch (error) {
                    console.error("showPicker() is not supported or was cancelled.", error);
                    alert("Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù‡Ù…Ø© ÙŠØ¯ÙˆÙŠÙ‹Ø§.");
                }
                rescheduleFlyout.classList.add('hidden');
                return;
            }

            recentlyRescheduledTask = {
                taskId: task.id,
                originalDate: new Date(task.date)
            };

            const newDate = new Date(task.date);
            let infoMessage = '';

            switch (period) {
                case 'tomorrow': newDate.setDate(newDate.getDate() + 1); infoMessage = 'Ø¥Ù„Ù‰ Ø§Ù„ØºØ¯'; break;
                case 'plus_two_days': newDate.setDate(newDate.getDate() + 2); infoMessage = 'Ø¨Ø¹Ø¯ ÙŠÙˆÙ…ÙŠÙ†'; break;
                case 'next_week': newDate.setDate(newDate.getDate() + 7); infoMessage = 'Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù…'; break;
                case 'plus_two_weeks': newDate.setDate(newDate.getDate() + 14); infoMessage = 'Ø¨Ø¹Ø¯ Ø£Ø³Ø¨ÙˆØ¹ÙŠÙ†'; break;
                case 'next_month': newDate.setMonth(newDate.getMonth() + 1); infoMessage = 'Ø¥Ù„Ù‰ Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ù‚Ø§Ø¯Ù…'; break;
                case 'next_quarter': newDate.setMonth(newDate.getMonth() + 3); infoMessage = 'Ø¥Ù„Ù‰ Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ù‚Ø§Ø¯Ù…'; break;
                case 'plus_two_quarters': newDate.setMonth(newDate.getMonth() + 6); infoMessage = 'Ø¨Ø¹Ø¯ Ø±Ø¨Ø¹ÙŠÙ†'; break;
                case 'next_year': newDate.setFullYear(newDate.getFullYear() + 1); infoMessage = 'Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø§Ù… Ø§Ù„Ù‚Ø§Ø¯Ù…'; break;
                case 'plus_two_years': newDate.setFullYear(newDate.getFullYear() + 2); infoMessage = 'Ø¨Ø¹Ø¯ Ø¹Ø§Ù…ÙŠÙ†'; break;
            }

            task.date = newDate;
            task.rescheduleCount = (task.rescheduleCount || 0) + 1;
            saveTasks();
            rescheduleFlyout.classList.add('hidden');
            renderApp();
            showActionSnackbar(`ØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ù…Ù‡Ù…Ø© ${infoMessage}`, 'success', handleUndoReschedule);
        }
        function handleRescheduleDatePick(event) {
            const taskId = parseInt(event.target.dataset.taskId, 10);
            const newDateStr = event.target.value;
            const task = findTask(taskId);

            if (task && newDateStr) {
                recentlyRescheduledTask = {
                    taskId: task.id,
                    originalDate: new Date(task.date)
                };
                
                const [year, month, day] = newDateStr.split('-').map(Number);
                const newDate = new Date(task.date);
                newDate.setFullYear(year, month - 1, day);
                if (task.time) {
                    const [hours, minutes] = task.time.split(':').map(Number);
                    newDate.setHours(hours, minutes);
                }

                task.date = newDate;
                task.rescheduleCount = (task.rescheduleCount || 0) + 1;
                saveTasks();
                
                rescheduleFlyout.classList.add('hidden');
                
                renderApp();
                const formattedDate = newDate.toLocaleDateString('ar-EG', { weekday: 'long', day: 'numeric', month: 'long' });
                showActionSnackbar(`ØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ù…Ù‡Ù…Ø© Ø¥Ù„Ù‰ ${formattedDate}`, 'success', handleUndoReschedule);
                
                event.target.value = '';
                event.target.removeAttribute('data-task-id');
            }
        }
        function handleNavDragEnter(event) {
            event.preventDefault();
            const draggedTask = findTask(draggedTaskId);
            if (draggedTask && draggedTask.viewMode === currentDateViewMode) {
                dateNavContainer.classList.add('drop-target-active');
            }
        }
        function handleNavDragOver(event) {
            event.preventDefault();
            const draggedTask = findTask(draggedTaskId);
            if (!draggedTask || draggedTask.viewMode !== currentDateViewMode) {
                 event.dataTransfer.dropEffect = 'none';
                 return;
            }
            event.dataTransfer.dropEffect = 'move';
            
            const targetEl = event.target.closest('.nav-item, .week-nav-item');
            if (targetEl && targetEl !== currentHoveredNavElement) {
                if (currentHoveredNavElement) {
                    currentHoveredNavElement.classList.remove('drop-hover');
                }
                targetEl.classList.add('drop-hover');
                currentHoveredNavElement = targetEl;
            } else if (!targetEl && currentHoveredNavElement) {
                currentHoveredNavElement.classList.remove('drop-hover');
                currentHoveredNavElement = null;
            }
        }
        function handleNavDragLeave(event) {
            if (!dateNavContainer.contains(event.relatedTarget)) {
                dateNavContainer.classList.remove('drop-target-active');
                if (currentHoveredNavElement) {
                    currentHoveredNavElement.classList.remove('drop-hover');
                    currentHoveredNavElement = null;
                }
            }
        }
        function handleNavDrop(event) {
            event.preventDefault();
            const targetEl = event.target.closest('.nav-item, .week-nav-item');
            const task = findTask(draggedTaskId);
            
            if (targetEl && task && task.viewMode === currentDateViewMode) {
                const newDateStr = targetEl.dataset.date;
                if (newDateStr) {
                    recentlyRescheduledTask = {
                        taskId: task.id,
                        originalDate: new Date(task.date)
                    };

                    const newDate = parseDateInput(newDateStr);
                    if (task.viewMode === 'days' && task.time) {
                        const [hours, minutes] = task.time.split(':').map(Number);
                        newDate.setHours(hours, minutes);
                    }
                    task.date = newDate;
                    task.rescheduleCount = (task.rescheduleCount || 0) + 1;
                    saveTasks();
                    
                    let formattedNewDate = '';
                    switch(currentDateViewMode){
                        case 'days': formattedNewDate = newDate.toLocaleDateString('ar-EG', { weekday: 'long', day: 'numeric' }); break;
                        case 'weeks': formattedNewDate = `Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${getWeekNumber(newDate)[1]}`; break;
                        case 'months': formattedNewDate = ARABIC_MONTHS[newDate.getMonth()]; break;
                        case 'quarters': formattedNewDate = ARABIC_QUARTERS[Math.floor(newDate.getMonth()/3)]; break;
                        case 'years': formattedNewDate = `Ø³Ù†Ø© ${newDate.getFullYear()}`; break;
                    }
                    
                    showActionSnackbar(`ØªÙ… Ù†Ù‚Ù„ "${task.title.substring(0, 15)}..." Ø¥Ù„Ù‰ ${formattedNewDate}`, 'success', handleUndoReschedule);
                    
                    viewDates[currentDateViewMode] = newDate;
                    updateSelectionForNewView();
                    renderApp();
                }
            }
        }

        // --- UNCHANGED FUNCTIONS CONTINUED ---
        function toggleFilterDropdown() { if (filterDropdownContent) { const isHidden = filterDropdownContent.classList.toggle('hidden'); filterIconBtn.setAttribute('aria-expanded', !isHidden); } }
        function saveTasks() { try { const tasksToSave = tasks.map(task => { const { timerIntervalId, ...restOfTask } = task; return restOfTask; }); const sortedTasksToSave = [...tasksToSave].sort((a, b) => (a.order || 0) - (b.order || 0)); localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(sortedTasksToSave)); } catch (error) { console.error("Error saving tasks:", error); } }
        function findTask(id) { return tasks.find(task => task.id === id); }
        function getTasks() { return [...tasks]; }
        function getPendingDeleteTask() { return recentlyDeletedTask; }
        function deleteTaskWithUndoInternal(taskId) { clearTimeout(undoDeleteTimeoutId); const taskIndex = tasks.findIndex(t => t.id === taskId); if (taskIndex === -1) return false; const taskToDelete = { ...tasks[taskIndex], originalOrder: tasks[taskIndex].order || (taskIndex + 1) }; if(taskToDelete.timerActive) { pauseTaskTimer(taskId); } recentlyDeletedTask = taskToDelete; tasks.splice(taskIndex, 1); saveTasks(); saveCategories(); showActionSnackbar(`ØªÙ… Ø­Ø°Ù "${taskToDelete.title}"`, 'delete', handleUndoDeleteInternal); return true; }
        function handleUndoDeleteInternal() { if (!recentlyDeletedTask) return; clearTimeout(undoDeleteTimeoutId); undoDeleteTimeoutId = null; tasks.push(recentlyDeletedTask); tasks.sort((a, b) => (a.order || tasks.length) - (b.order || tasks.length)); tasks.forEach((task, index) => { task.order = index + 1; }); const undoneTask = { ...recentlyDeletedTask }; recentlyDeletedTask = null; saveTasks(); saveCategories(); hideActionSnackbar(); renderApp(); highlightTask(undoneTask.id); }
        function confirmDelete(taskId) { if (recentlyDeletedTask && recentlyDeletedTask.id === taskId) { recentlyDeletedTask = null; } }
                function handleUndoReschedule() { if (!recentlyRescheduledTask) return; clearTimeout(undoRescheduleTimeoutId); undoRescheduleTimeoutId = null; const task = findTask(recentlyRescheduledTask.taskId); if (task) { task.date = recentlyRescheduledTask.originalDate; saveTasks(); const undoneTask = { ...task }; recentlyRescheduledTask = null; hideActionSnackbar(); renderApp(); showActionSnackbar(`ØªÙ… Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù†Ù‚Ù„ "${undoneTask.title.substring(0, 20)}..."`, 'info'); highlightTask(undoneTask.id); } }
        function updateTaskOrderInternal(draggedId, targetId) { const draggedIndex = tasks.findIndex(t => t.id === draggedId); let targetIndex = tasks.findIndex(t => t.id === targetId); if (draggedIndex === -1 || targetIndex === -1) return false; const [draggedItem] = tasks.splice(draggedIndex, 1); const finalTargetIndex = tasks.findIndex(t => t.id === targetId); tasks.splice(finalTargetIndex, 0, draggedItem); tasks.forEach((task, index) => { task.order = index + 1; }); saveTasks(); return true; }
        function clearDragOverPlaceholder() { if (taskListContainer) { taskListContainer.querySelectorAll('.task-drag-over').forEach(el => el.classList.remove('task-drag-over')); } }
        function handleDragStart(event) { const taskItem = event.target.closest('.task-item'); if (!taskItem || taskItem.querySelector('input[type="checkbox"]')?.checked) { event.preventDefault(); return; } draggedTaskId = parseInt(taskItem.dataset.taskId); event.dataTransfer.effectAllowed = 'move'; event.dataTransfer.setData('text/plain', draggedTaskId.toString()); setTimeout(() => { taskItem.classList.add('task-dragging'); }, 0); if (taskListContainer) taskListContainer.classList.add('dragging-active'); }
        function handleDragOver(event) { event.preventDefault(); const targetElement = event.target.closest('.task-item:not(.task-dragging)'); if (targetElement) { const targetTaskId = parseInt(targetElement.dataset.taskId); const isTargetCompleted = targetElement.querySelector('input[type="checkbox"]')?.checked; if (targetTaskId === draggedTaskId || isTargetCompleted) { clearDragOverPlaceholder(); dragOverTaskId = null; event.dataTransfer.dropEffect = 'none'; return; } if (targetTaskId !== dragOverTaskId) { clearDragOverPlaceholder(); targetElement.classList.add('task-drag-over'); dragOverTaskId = targetTaskId; } event.dataTransfer.dropEffect = 'move'; } else { clearDragOverPlaceholder(); dragOverTaskId = null; } }
        function handleDragLeave(event) { const leavingElement = event.target.closest('.task-item'); const relatedTargetAsTaskItem = event.relatedTarget?.closest('.task-item'); if (leavingElement && leavingElement.classList.contains('task-drag-over') && leavingElement !== relatedTargetAsTaskItem) { clearDragOverPlaceholder(); dragOverTaskId = null; } else if (taskListContainer && !taskListContainer.contains(event.relatedTarget)) { clearDragOverPlaceholder(); dragOverTaskId = null; } }
        function handleDrop(event) { event.preventDefault(); clearDragOverPlaceholder(); const currentDraggedId = draggedTaskId; const currentTargetId = dragOverTaskId; handleDragEnd(); if (currentDraggedId === null || currentTargetId === null || currentDraggedId === currentTargetId) { return; } const success = updateTaskOrderInternal(currentDraggedId, currentTargetId); if (success) { renderApp(); } }
        function handleDragEnd() { document.querySelectorAll('.task-dragging').forEach(el => el.classList.remove('task-dragging')); clearDragOverPlaceholder(); if (taskListContainer) taskListContainer.classList.remove('dragging-active'); if (dateNavContainer) { dateNavContainer.classList.remove('drop-target-active'); if (currentHoveredNavElement) { currentHoveredNavElement.classList.remove('drop-hover'); currentHoveredNavElement = null; } } draggedTaskId = null; dragOverTaskId = null; }
        function resetSwipeState(taskItem) { clearTimeout(swipeAnimationTimeout); if (taskItem) { taskItem.classList.remove('swiping', 'swipe-ready-delete', 'swipe-ready-star', 'swipe-delete-active', 'swipe-reset-active'); taskItem.style.transform = ''; taskItem.style.willChange = ''; taskItem.style.transition = ''; taskItem.querySelectorAll('.swipe-indicator').forEach(indicator => indicator.style.opacity = 0); if (taskItem._touchStartY) delete taskItem._touchStartY; } swipingTaskId = null; touchStartX = 0; touchCurrentX = 0; isSwiping = false; swipePreventScroll = false; }
        function handleTouchStart(event) { const taskItem = event.target.closest('.task-item'); if (!taskItem || event.touches.length > 1 || taskItem.classList.contains('task-dragging') || event.target.closest('button, input, select, textarea, a, .task-details-container') || taskItem.querySelector('input[type="checkbox"]')?.checked) { resetSwipeState(null); return; } if (swipeAnimationTimeout) return; swipingTaskId = parseInt(taskItem.dataset.taskId); touchStartX = event.touches[0].clientX; touchCurrentX = touchStartX; isSwiping = false; swipePreventScroll = false; taskItem.style.willChange = 'transform'; taskItem._touchStartY = event.touches[0].clientY; taskItem.classList.remove('swipe-ready-delete', 'swipe-ready-star', 'swipe-delete-active', 'swipe-reset-active'); taskItem.querySelectorAll('.swipe-indicator').forEach(indicator => indicator.style.opacity = 0); }
        function handleTouchMove(event) { if (swipingTaskId === null || event.touches.length > 1 || swipeAnimationTimeout) return; const taskItem = taskListContainer.querySelector(`.task-item[data-task-id="${swipingTaskId}"]`); if (!taskItem) { resetSwipeState(null); return; } touchCurrentX = event.touches[0].clientX; const touchCurrentY = event.touches[0].clientY; const deltaX = touchCurrentX - touchStartX; const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(touchCurrentY - (taskItem._touchStartY || touchCurrentY)); if (!isSwiping && !swipePreventScroll) { const threshold = 8; if (absDeltaX > threshold || absDeltaY > threshold) { if (absDeltaX > absDeltaY * 1.2) { isSwiping = true; swipePreventScroll = true; taskItem.classList.add('swiping'); } else { swipePreventScroll = true; resetSwipeState(taskItem); return; } } else { return; } } if (isSwiping) { if (event.cancelable) event.preventDefault(); const translateX = Math.max(-SWIPE_MAX_TRANSLATE, Math.min(SWIPE_MAX_TRANSLATE, deltaX)); taskItem.style.transform = `translateX(${translateX}px)`; const swipeDirection = deltaX > 0 ? 'right' : 'left'; const strength = Math.min(1, absDeltaX / SWIPE_THRESHOLD); const leftIndicator = taskItem.querySelector('.swipe-indicator.left'); const rightIndicator = taskItem.querySelector('.swipe-indicator.right'); if (leftIndicator && rightIndicator) { leftIndicator.style.opacity = swipeDirection === 'left' ? strength : 0; rightIndicator.style.opacity = swipeDirection === 'right' ? strength : 0; taskItem.classList.toggle('swipe-ready-delete', swipeDirection === 'left' && strength > 0.7); taskItem.classList.toggle('swipe-ready-star', swipeDirection === 'right' && strength > 0.7); } } }
        function handleTouchEnd(event) { const taskItem = taskListContainer.querySelector(`.task-item[data-task-id="${swipingTaskId}"]`); if (swipingTaskId === null || !isSwiping || swipeAnimationTimeout || !taskItem) { resetSwipeState(taskItem); return; } const currentSwipedItemId = swipingTaskId; taskItem.classList.remove('swiping', 'swipe-ready-delete', 'swipe-ready-star'); taskItem.style.willChange = 'auto'; taskItem.querySelectorAll('.swipe-indicator').forEach(indicator => indicator.style.opacity = 0); const deltaX = touchCurrentX - touchStartX; const absDeltaX = Math.abs(deltaX); if (absDeltaX > SWIPE_THRESHOLD) { taskItem.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out'; swipeAnimationTimeout = setTimeout(() => { console.warn("Swipe action fallback triggered for item:", currentSwipedItemId); swipeAnimationTimeout = null; const stillExists = !!taskListContainer.querySelector(`.task-item[data-task-id="${currentSwipedItemId}"]`); if(stillExists && taskItem.classList.contains('swipe-delete-active')) { deleteTaskWithUndoInternal(currentSwipedItemId); renderApp(); } resetSwipeState(taskItem); }, 400); if (deltaX < 0) { taskItem.classList.add('swipe-delete-active'); taskItem.addEventListener('transitionend', function onDeleteTransitionEnd(ev) { clearTimeout(swipeAnimationTimeout); swipeAnimationTimeout = null; if (swipingTaskId === currentSwipedItemId) { deleteTaskWithUndoInternal(currentSwipedItemId); renderApp(); resetSwipeState(null); } else { resetSwipeState(taskItem); } }, { once: true }); } else { toggleTaskStarInternal(currentSwipedItemId); taskItem.classList.add('swipe-reset-active'); taskItem.style.transform = 'translateX(0)'; taskItem.addEventListener('transitionend', function onStarTransitionEnd(ev) { clearTimeout(swipeAnimationTimeout); swipeAnimationTimeout = null; taskItem.style.transform = ''; if (swipingTaskId === currentSwipedItemId) { renderApp(); resetSwipeState(null); } else { resetSwipeState(taskItem); } }, { once: true }); } } else { taskItem.style.transition = 'transform 0.3s ease-out'; swipeAnimationTimeout = setTimeout(() => { console.warn("Swipe reset fallback triggered (threshold not met)"); swipeAnimationTimeout = null; resetSwipeState(taskItem); }, 400); taskItem.classList.add('swipe-reset-active'); taskItem.style.transform = 'translateX(0)'; taskItem.addEventListener('transitionend', function onResetTransitionEnd(ev) { clearTimeout(swipeAnimationTimeout); swipeAnimationTimeout = null; taskItem.style.transform = ''; if (swipingTaskId === currentSwipedItemId) { resetSwipeState(null); } else { resetSwipeState(taskItem); } }, { once: true }); } if (taskItem._touchStartY) delete taskItem._touchStartY; }
        function handleTouchCancel(event) { console.log("Touch cancel event triggered."); const taskItem = taskListContainer.querySelector(`.task-item[data-task-id="${swipingTaskId}"]`); resetSwipeState(taskItem); }
        function getTimeRemainingString(dueDate, nowDate) { if (!dueDate || isNaN(dueDate.getTime())) return null; const diffMilliseconds = dueDate.getTime() - nowDate.getTime(); const diffSeconds = Math.round(diffMilliseconds / 1000); if (diffSeconds <= 0) return "Ù…ØªØ£Ø®Ø±"; const diffMinutes = Math.floor(diffSeconds / 60); const diffHours = Math.floor(diffMinutes / 60); const diffDays = Math.floor(diffHours / 24); const tomorrow = new Date(nowDate); tomorrow.setDate(nowDate.getDate() + 1); tomorrow.setHours(0, 0, 0, 0); const dueDateStartOfDay = new Date(dueDate); dueDateStartOfDay.setHours(0, 0, 0, 0); if (isSameDay(dueDateStartOfDay, tomorrow)) return "ØºØ¯Ù‹Ø§"; if (diffDays > 1) return `Ø¨Ø§Ù‚ÙŠ ${diffDays} ${diffDays <= 10 ? 'Ø£ÙŠØ§Ù…' : 'ÙŠÙˆÙ…'}`; if (diffHours >= 1) { const remainingMinutes = diffMinutes % 60; let timeStr = `Ø¨Ø§Ù‚ÙŠ ${diffHours} ${diffHours === 1 ? 'Ø³Ø§Ø¹Ø©' : (diffHours === 2 ? 'Ø³Ø§Ø¹ØªÙŠÙ†' : (diffHours <= 10 ? 'Ø³Ø§Ø¹Ø§Øª' : 'Ø³Ø§Ø¹Ø©'))}`; if (remainingMinutes > 0 && diffHours < 6) timeStr += ` Ùˆ ${remainingMinutes} Ø¯`; return timeStr; } if (diffMinutes >= 1) return `Ø¨Ø§Ù‚ÙŠ ${diffMinutes} ${diffMinutes === 1 ? 'Ø¯Ù‚ÙŠÙ‚Ø©' : (diffMinutes === 2 ? 'Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†' : (diffMinutes <= 10 ? 'Ø¯Ù‚Ø§Ø¦Ù‚' : 'Ø¯Ù‚ÙŠÙ‚Ø©'))}`; return "Ø£Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚Ø©"; }
        function updateSingleCountdown(originalTask, taskViewData, countdownElement) { if (!countdownElement) return; const hasTimer = originalTask.duration?.unit === 'minutes'; const shouldShowCountdownForThisTask = (widgetSettings.countdownEnabled && !hasTimer) || (widgetSettings.countdownEnabled && hasTimer && originalTask.showCountdownWithDurationTimer); if (!shouldShowCountdownForThisTask) { countdownElement.style.display = 'none'; return; } const countdownTextElement = countdownElement.querySelector('.countdown-text'); if (!countdownTextElement) return; if (taskViewData.completed) { countdownElement.style.display = 'none'; return; } let dueDateForCountdown = null; if (originalTask.date && !isNaN(originalTask.date.getTime())) { dueDateForCountdown = new Date(originalTask.date); if (!originalTask.time) { dueDateForCountdown.setHours(23, 59, 59, 999); } } if (!dueDateForCountdown || isNaN(dueDateForCountdown.getTime())) { countdownElement.style.display = 'none'; return; } countdownElement.dataset.dueTimestamp = dueDateForCountdown.getTime(); const now = new Date(); const remainingString = getTimeRemainingString(dueDateForCountdown, now); const currentThresholdHours = originalTask.countdownThresholdOverrideHours !== null ? originalTask.countdownThresholdOverrideHours : widgetSettings.countdownSoonThresholdHours; if (remainingString) { countdownElement.textContent = remainingString; countdownElement.style.display = 'flex'; countdownElement.classList.remove('overdue', 'soon'); if (remainingString === "Ù…ØªØ£Ø®Ø±") { countdownElement.classList.add('overdue'); } else { const diffHours = (dueDateForCountdown.getTime() - now.getTime()) / (1000 * 60 * 60); if (diffHours < currentThresholdHours && diffHours >= 0) { countdownElement.classList.add('soon'); } } } else { countdownElement.style.display = 'none'; } }
        function updateAllCountdowns() { const needsInterval = widgetSettings.countdownEnabled || tasks.some(t => t.showCountdownWithDurationTimer && t.duration?.unit === 'minutes'); if (!needsInterval) { if (taskListContainer) taskListContainer.querySelectorAll('.task-countdown').forEach(el => el.style.display = 'none'); return; } if (!taskListContainer) return; const now = new Date(); const taskItems = taskListContainer.querySelectorAll('.task-item'); taskItems.forEach(taskItem => { const countdownElement = taskItem.querySelector('.task-countdown'); if (!countdownElement) return; const taskId = parseInt(taskItem?.dataset.taskId); const originalTask = findTask(taskId); if (!originalTask) { countdownElement.style.display = 'none'; return; } const hasTimer = originalTask.duration?.unit === 'minutes'; const shouldShowCountdownForThisTask = (widgetSettings.countdownEnabled && !hasTimer) || (widgetSettings.countdownEnabled && hasTimer && originalTask.showCountdownWithDurationTimer); if (!shouldShowCountdownForThisTask) { countdownElement.style.display = 'none'; return; } const isCompleted = taskItem?.querySelector('input[type="checkbox"]')?.checked; if (isCompleted) { countdownElement.style.display = 'none'; return; } const timestampStr = countdownElement.dataset.dueTimestamp; if (!timestampStr) { let dueDateForCountdown = null; if (originalTask.date && !isNaN(originalTask.date.getTime())) { dueDateForCountdown = new Date(originalTask.date); if (!originalTask.time) { dueDateForCountdown.setHours(23, 59, 59, 999); } countdownElement.dataset.dueTimestamp = dueDateForCountdown.getTime(); } else { countdownElement.style.display = 'none'; return; } } const dueDate = new Date(parseInt(countdownElement.dataset.dueTimestamp, 10)); if (isNaN(dueDate.getTime())) { countdownElement.style.display = 'none'; return; } const newRemainingString = getTimeRemainingString(dueDate, now); const textSpan = countdownElement.querySelector('.countdown-text'); const currentThresholdHours = originalTask.countdownThresholdOverrideHours !== null ? originalTask.countdownThresholdOverrideHours : widgetSettings.countdownSoonThresholdHours; if (textSpan) { if (newRemainingString) { if (textSpan.textContent !== newRemainingString || countdownElement.style.display === 'none') { textSpan.textContent = newRemainingString; countdownElement.style.display = 'flex'; countdownElement.classList.remove('overdue', 'soon'); if (newRemainingString === "Ù…ØªØ£Ø®Ø±") { countdownElement.classList.add('overdue'); } else { const diffHours = (dueDate.getTime() - now.getTime()) / (1000 * 60 * 60); if (diffHours < currentThresholdHours && diffHours >= 0) { countdownElement.classList.add('soon'); } } } } else { countdownElement.style.display = 'none'; } } }); }
        function updateCountdownTimerInterval() { const needsInterval = widgetSettings.countdownEnabled || tasks.some(t => t.showCountdownWithDurationTimer && t.duration?.unit === 'minutes'); if (needsInterval && !countdownIntervalId) { countdownIntervalId = setInterval(updateAllCountdowns, COUNTDOWN_UPDATE_INTERVAL); console.log("Due date countdown timer started/re-evaluated."); } else if (!needsInterval && countdownIntervalId) { clearInterval(countdownIntervalId); countdownIntervalId = null; if (taskListContainer) { taskListContainer.querySelectorAll('.task-countdown').forEach(el => el.style.display = 'none'); } console.log("Due date countdown timer stopped."); } }
        function formatTimerDisplay(totalSeconds) { if (totalSeconds === null || totalSeconds < 0) return "00:00"; const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }
        function updateTaskTimerDisplay(taskId) { const task = findTask(taskId); const taskElement = taskListContainer.querySelector(`.task-item[data-task-id="${taskId}"]`); if (!taskElement || !task) return; const timerDisplayElement = taskElement.querySelector('.task-timer-display'); if (timerDisplayElement && task.duration?.unit === 'minutes') { const timeToDisplay = task.timerRemainingSeconds ?? (task.duration.value * 60); timerDisplayElement.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg><span>${formatTimerDisplay(timeToDisplay)}</span>`; timerDisplayElement.classList.toggle('active', task.timerActive); } else if (timerDisplayElement) { timerDisplayElement.innerHTML = ''; } }
        function handlePlayPauseTimer(taskId) { const task = findTask(taskId); if (!task) return; if (task.timerActive) { pauseTaskTimer(taskId); } else { startTaskTimer(taskId); } }

        function startTaskTimer(taskId) {
            const task = findTask(taskId);
            if (!task || task.completed || task.duration?.unit !== 'minutes' || task.timerActive) return;
            tasks.forEach(t => { if (t.id !== taskId && t.timerActive) pauseTaskTimer(t.id); });
            task.timerActive = true;
            task.timerWasActivePreviously = true;
            if (task.timerRemainingSeconds === null || task.timerRemainingSeconds <= 0) {
                task.timerRemainingSeconds = task.duration.value * 60;
            }
            task.timerStartTime = Date.now();
            if (task.timerIntervalId) clearInterval(task.timerIntervalId);
            if (!document.title.match(/\(\d{2}:\d{2}\)/)) {
                originalPageTitle = document.title;
            }
            task.timerNotifiedAlmostDone = false;
            task.timerIntervalId = setInterval(() => {
                if (!task.timerActive) {
                    clearInterval(task.timerIntervalId);
                    task.timerIntervalId = null;
                    if (document.title.includes(`(${formatTimerDisplay(task.timerRemainingSeconds || 0)}) ${task.title.substring(0, 20)}`)) {
                        document.title = originalPageTitle;
                    }
                    return;
                }
                const elapsedSinceTimerStart = Math.floor((Date.now() - task.timerStartTime) / 1000);
                const initialSecondsForThisRun = task.timerInitialSecondsOnStart ?? (task.duration.value * 60);
                task.timerRemainingSeconds = Math.max(0, initialSecondsForThisRun - elapsedSinceTimerStart);
                if (!task.timerNotifiedAlmostDone && task.timerRemainingSeconds > 0 && task.timerRemainingSeconds <= TIMER_ALMOST_DONE_THRESHOLD_SECONDS) {
                    showBrowserNotification(`Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„Ù…Ù‡Ù…Ø© "${task.title}" Ù‚Ù„ÙŠÙ„`, `Ù…ØªØ¨Ù‚ÙŠ ${formatTimerDisplay(task.timerRemainingSeconds)} Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©.`);
                    task.timerNotifiedAlmostDone = true;
                }
                if (task.timerRemainingSeconds <= 0) {
                    task.timerRemainingSeconds = 0;
                    pauseTaskTimer(taskId);
                    showBrowserNotification(`Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ù…Ù‡Ù…Ø©: ${task.title}`, `Ù„Ù‚Ø¯ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø®ØµØµ Ù„Ù…Ù‡Ù…Ø© "${task.title}".`);
                    console.log(`Timer for task "${task.title}" finished.`);
                }
                updateTaskTimerDisplay(taskId);
                document.title = `(${formatTimerDisplay(task.timerRemainingSeconds)}) ${task.title.substring(0, 20)}...`;
                saveTasks();
            }, TASK_TIMER_UPDATE_INTERVAL);
            task.timerInitialSecondsOnStart = task.timerRemainingSeconds;
            updateTaskTimerDisplay(taskId);
            document.title = `(${formatTimerDisplay(task.timerRemainingSeconds)}) ${task.title.substring(0, 20)}...`;
            saveTasks();
        }

        function pauseTaskTimer(taskId) {
            const task = findTask(taskId);
            if (task && task.timerActive) {
                clearInterval(task.timerIntervalId);
                task.timerIntervalId = null;
                task.timerActive = false;
                if (document.title.includes(`(${formatTimerDisplay(task.timerRemainingSeconds || 0)}) ${task.title.substring(0, 20)}`)) {
                    document.title = originalPageTitle;
                }
                updateTaskTimerDisplay(taskId);
                saveTasks();
                console.log(`Timer for task "${task.title}" paused at ${formatTimerDisplay(task.timerRemainingSeconds)}.`);
            }
        }

        function resetTaskTimer(taskId) {
            const task = findTask(taskId);
            if (task) {
                if (task.timerActive) {
                    pauseTaskTimer(taskId);
                } else if (document.title.includes(task.title.substring(0, 20))) {
                    document.title = originalPageTitle;
                }
                task.timerRemainingSeconds = task.duration?.unit === 'minutes' ? task.duration.value * 60 : null;
                task.timerInitialSecondsOnStart = undefined;
                task.timerNotifiedAlmostDone = false;
                task.timerWasActivePreviously = false;
                updateTaskTimerDisplay(taskId);
                saveTasks();
                console.log(`Timer for task "${task.title}" has been reset.`);
            }
        }

        function removeTaskTimer(taskId) {
            const task = findTask(taskId);
            if (task) {
                if (task.timerActive) {
                    pauseTaskTimer(taskId);
                } else if (document.title.includes(task.title.substring(0, 20))) {
                    document.title = originalPageTitle;
                }
                task.duration = null;
                task.timerRemainingSeconds = null;
                task.timerActive = false;
                task.timerInitialSecondsOnStart = undefined;
                task.timerNotifiedAlmostDone = false;
                task.timerWasActivePreviously = false;
                if (task.timerIntervalId) clearInterval(task.timerIntervalId);
                task.timerIntervalId = null;
                saveTasks();
                renderApp();
                console.log(`Timer completely removed for task "${task.title}".`);
            }
        }

        function requestNotificationPermission() { if (!("Notification" in window)) { console.log("This browser does not support desktop notification"); notificationPermissionGranted = false; return; } if (Notification.permission === "granted") { notificationPermissionGranted = true; } else if (Notification.permission !== "denied") { Notification.requestPermission().then(permission => { notificationPermissionGranted = (permission === "granted"); if (notificationPermissionGranted) { console.log("Notification permission granted."); } else { console.log("Notification permission denied by user."); } }); } else { notificationPermissionGranted = false; } }
        function showBrowserNotification(title, body) { if (!notificationPermissionGranted) { console.log("Cannot show notification, permission not granted. Alerting instead."); alert(`${title}\n${body}`); return; } const options = { body: body, icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="%233b82f6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><path d="m9 12 2 2 4-4"></path></svg>', dir: 'rtl', badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="%233b82f6"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path></svg>' }; try { new Notification(title, options); } catch (err) { console.error("Error showing notification (possibly due to badge):", err); const { badge, ...fallbackOptions } = options; new Notification(title, fallbackOptions); } }
        function updateHeaderDate() { }
        function navigatePeriod(direction) {
            AdvancedStatsHandler.hide();
            lastClickedDateStr = null;
            const currentDate = new Date(viewDates[currentDateViewMode]); 
            const increment = direction === 'next' ? 1 : -1; 
            switch(currentDateViewMode) { 
                case 'days': currentDate.setDate(currentDate.getDate() + (7 * increment)); break; 
                case 'weeks': currentDate.setMonth(currentDate.getMonth() + increment); break; 
                case 'months': currentDate.setFullYear(currentDate.getFullYear() + increment); break; 
                case 'quarters': currentDate.setMonth(currentDate.getMonth() + (3 * increment)); break; 
                case 'years': currentDate.setFullYear(currentDate.getFullYear() + (5 * increment)); break; 
            } 
            viewDates[currentDateViewMode] = currentDate; 
            updateSelectionForNewView(); 
            renderApp(); 
        }
                        function renderDateNav() { if (!dateNavContainer) return; dateNavContainer.innerHTML = ''; dateNavContainer.className = 'flex-grow flex items-center gap-1 relative'; const isScrollable = ['days', 'weeks', 'months', 'quarters', 'years'].includes(currentDateViewMode); dateNavContainer.style.cursor = isScrollable ? 'grab' : 'default'; switch (currentDateViewMode) { case 'days': renderDaysView(); break; case 'weeks': renderWeeksView(); break; case 'months': renderMonthsView(); break; case 'quarters': renderQuartersView(); break; case 'years': renderYearsView(); break; } updateSmartViewSwitcher(); dateViewDropdown.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active', btn.dataset.view === currentDateViewMode); }); }
        function getWeeksForMonth(year, month) { const weeks = []; const getLastDayOfMonth = (yr, m) => new Date(yr, m + 1, 0); const firstDayOfMonth = new Date(year, month, 1); const lastDayOfMonth = getLastDayOfMonth(year, month); let currentDay = getStartOfWeek(firstDayOfMonth); while (currentDay <= lastDayOfMonth) { const weekStart = new Date(currentDay); const weekEnd = new Date(weekStart); weekEnd.setDate(weekStart.getDate() + 6); const [, weekNum] = getWeekNumber(weekStart); weeks.push({ weekNum, start: weekStart, end: weekEnd }); currentDay.setDate(currentDay.getDate() + 7); } return weeks; }
        const getStartOfWeek = (date) => { const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1); d.setDate(diff); d.setHours(0,0,0,0); return d; };
        function getNextDayOfWeek(startDate, dayOfWeek, hours = 0, minutes = 0) { const resultDate = new Date(startDate.getTime()); const daysToAdd = (dayOfWeek + 7 - startDate.getDay()) % 7; resultDate.setDate(startDate.getDate() + (daysToAdd === 0 ? 7 : daysToAdd)); resultDate.setHours(hours, minutes, 0, 0); return resultDate; }
        function shouldShowRecurringTask(task, targetDisplayDate) { return false; } // Simplified for brevity
        function getNextOccurrenceDate(task, afterDate) { return null; } // Simplified
        function loadWidgetSettings() { try { const storedSettings = localStorage.getItem(LOCAL_STORAGE_SETTINGS_KEY); if (storedSettings) { const parsedSettings = JSON.parse(storedSettings); widgetSettings.countdownEnabled = parsedSettings.countdownEnabled ?? true; widgetSettings.countdownSoonThresholdHours = parsedSettings.countdownSoonThresholdHours ?? 4; } } catch (error) { console.error("Error loading widget settings:", error); } console.log("Widget settings loaded:", widgetSettings); }
        function saveWidgetSettings() { try { localStorage.setItem(LOCAL_STORAGE_SETTINGS_KEY, JSON.stringify(widgetSettings)); console.log("Widget settings saved:", widgetSettings); } catch (error) { console.error("Error saving widget settings:", error); } }
        function loadAvailableCategories() { try { const storedCategories = localStorage.getItem(LOCAL_STORAGE_CATEGORIES_KEY); if (storedCategories) { availableCategories = JSON.parse(storedCategories); } else { availableCategories = []; } } catch (error) { console.error("Error loading available categories:", error); availableCategories = []; } }
        function saveAvailableCategories() { try { localStorage.setItem(LOCAL_STORAGE_CATEGORIES_KEY, JSON.stringify(availableCategories.sort())); } catch (error) { console.error("Error saving available categories:", error); } }
        function loadSavedCategories() { try { const storedSavedCategories = localStorage.getItem(LOCAL_STORAGE_SAVED_CATEGORIES_KEY); if (storedSavedCategories) { savedCategories = JSON.parse(storedSavedCategories); } else { savedCategories = []; } } catch (error) { console.error("Error loading saved categories:", error); savedCategories = []; } }
        function saveCategories() { saveAvailableCategories(); try { localStorage.setItem(LOCAL_STORAGE_SAVED_CATEGORIES_KEY, JSON.stringify(savedCategories.sort())); } catch (error) { console.error("Error saving saved categories:", error); } }
        function addCategoryIfNotExists(categoryName, skipSave = false) { const trimmedCategory = categoryName.trim(); if (trimmedCategory && !availableCategories.includes(trimmedCategory)) { availableCategories.push(trimmedCategory); if (!skipSave) saveCategories(); return true; } return false; }
        function removeCategoryCompletely(categoryName) { const trimmedCategory = categoryName.trim(); if (!trimmedCategory || trimmedCategory === DEFAULT_CATEGORY) { alert(`Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© "${DEFAULT_CATEGORY}".`); return; } const confirmMessage = `Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„ÙØ¦Ø© "${trimmedCategory}"ØŸ\nØ³ÙŠØªÙ… Ø¥Ø²Ø§Ù„ØªÙ‡Ø§ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ¦Ø§Øª ÙˆÙ…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‡Ø§Ù…ØŒ ÙˆØ³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡Ø§ Ø¨Ø§Ù„ÙØ¦Ø© "${DEFAULT_CATEGORY}" ÙÙŠ ØªÙ„Ùƒ Ø§Ù„Ù…Ù‡Ø§Ù….`; if (!confirm(confirmMessage)) { return; } const availableIdx = availableCategories.indexOf(trimmedCategory); if (availableIdx > -1) availableCategories.splice(availableIdx, 1); const savedIdx = savedCategories.indexOf(trimmedCategory); if (savedIdx > -1) savedCategories.splice(savedIdx, 1); tasks.forEach(task => { if (task.category === trimmedCategory) { task.category = DEFAULT_CATEGORY; } }); saveTasks(); saveCategories(); renderApp(); if (!addTaskModal.classList.contains('hidden')) { populateCategorySuggestionDropdown(); updateToggleSaveCategoryButtonState(newTaskCategoryInput.value); } console.log(`Category "${trimmedCategory}" removed completely.`); }
        function toggleSavedCategory(categoryName, fromDropdown = false) { const trimmedCategory = categoryName.trim(); if (!trimmedCategory) return; addCategoryIfNotExists(trimmedCategory); const index = savedCategories.indexOf(trimmedCategory); if (index > -1) { savedCategories.splice(index, 1); } else { savedCategories.push(trimmedCategory); } saveCategories(); updateToggleSaveCategoryButtonState(trimmedCategory); if (fromDropdown) { populateCategorySuggestionDropdown(); } else { populateCategoryDatalist(); } }
        function populateCategoryFilterSelect() { if (!categoryFilterSelect) return; const currentFilterValue = categoryFilterSelect.value; categoryFilterSelect.innerHTML = '<option value="all">ÙƒÙ„ Ø§Ù„ÙØ¦Ø§Øª</option>'; const uniqueDisplayCategories = new Set(availableCategories); tasks.forEach(task => { if (task.category) uniqueDisplayCategories.add(task.category); }); if (!uniqueDisplayCategories.has(DEFAULT_CATEGORY) && tasks.length > 0) { uniqueDisplayCategories.add(DEFAULT_CATEGORY); } Array.from(uniqueDisplayCategories).sort().forEach(category => { const optionElement = document.createElement('option'); optionElement.value = category; optionElement.textContent = category; categoryFilterSelect.appendChild(optionElement); }); if (uniqueDisplayCategories.has(currentFilterValue)) { categoryFilterSelect.value = currentFilterValue; } else { categoryFilterSelect.value = "all"; } }
        function toggleTaskStarInternal(taskId) { const task = findTask(taskId); if (task) { task.starred = !task.starred; saveTasks(); } }
    </script>

</body>
</html>